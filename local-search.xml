<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>第2章 变量和基本类型</title>
    <link href="/2023/08/21/Ch2-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"/>
    <url>/2023/08/21/Ch2-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="第2章-变量和基本类型">第2章 变量和基本类型</h1><h2 id="基本内置类型">1. 基本内置类型</h2><p>C++ 基本的数据类型有算术类型和空类型，算术类型就是基本的整型和浮点型的数据类型。</p><figure><img src="/2023/08/21/Ch2-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/基本数据类型.png" alt="基本数据类型"><figcaption aria-hidden="true">基本数据类型</figcaption></figure><p>不同类型之间的转换需要注意，有的转换可能是我们不想发生的。</p><p><strong>字面值常量</strong></p><ul><li>数值型，编译器会根据数字形式对应一种基本的数据类型。</li><li>字符和字符串字面常量</li><li>布尔字面值和指针字面值</li></ul><blockquote><p>与其他整型不同, 字符型被分为了三种：char、signed char 和 unsignedchar，但表现形式只有带符号和无符号两种。<strong>char实际上会表现为signed char和unsignedchar中的一种，由编译器决定。</strong></p></blockquote><h2 id="变量">2. 变量</h2><p>变量提供一个具名的、可供程序操作的存储空间。</p><p>###　2.1 变量定义</p><p>C++变量的定义要指定变量的类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//变量定义并初始化</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">2</span>;<br><span class="hljs-comment">//变量定义</span><br><span class="hljs-type">int</span> b;<br><span class="hljs-comment">//变量赋值</span><br>b = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><blockquote><p>在C++中变量的初始化和赋值是有区别的， <code>int a = 2;</code>的<code>=</code> 运算符表示的是初始化，</p><p>而在 <code>b=1;</code> 中的 <code>=</code> 是赋值。</p></blockquote><p><span style="border:2px solid Red">C++11</span> 初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> val = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> val = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> val&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">val</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>使用 <code>&#123;&#125;</code>来初始化变量，称为<strong>列表初始化</strong>，如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">long</span> <span class="hljs-type">double</span> pi = <span class="hljs-number">3.14</span>;<br><span class="hljs-type">int</span> a&#123;pi&#125;;<span class="hljs-comment">//错误，存在丢失信息的风险，无法通过编译</span><br></code></pre></td></tr></table></figure><blockquote><p>总结：C++变量初始化的语法形式有三种：<code>=</code> , <code>()</code>, <code>&#123;&#125;</code></p></blockquote><p><strong>默认初始化</strong>，定义变量时没有初始化变量的值，则变量会被默认初始化。默认初始化的值取决于变量定义的类型。==定义在函数体内的局部变量和类中的成员属性是不会被初始化的==所以不用试图使用任何方式去访问这些变量。</p><h3 id="声明和定义">2.2 声明和定义</h3><p><strong>声明</strong>，使程序知道变量（对象）的存在</p><p><strong>定义</strong>，负责创建与名字关联的实体 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> i;<span class="hljs-comment">//声明i而不定义</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<span class="hljs-comment">//extern失效,变成定义</span><br><span class="hljs-type">int</span> j;<span class="hljs-comment">//声明并定义j</span><br></code></pre></td></tr></table></figure><blockquote><p>变量能且只能被定义一次，但是可以被多次声明</p></blockquote><h3 id="标识符作用域">2.3-4 标识符、作用域</h3><h4 id="标识符">标识符</h4><p>变量命名按照规范，不要使用保留关键字。</p><p>==命名规则，供参考：==</p><ul><li>普通的局部变量和函数参数名使用小驼峰（第一个单词首字母小写，其他单词首字母大写），例： <code>userName</code></li><li>全局变量前加 <code>g_</code>, 后面的按小驼峰规则 ，<code>g_userName</code></li><li>静态变量前加 <code>s_</code> , 后面按小驼峰规则，<code>s_userName</code></li><li>类名使用大驼峰，所有单词的首字母大写 , <code>UserManage</code></li><li>类属性（成员变量）前面加 <code>m_</code> ,后面按小驼峰规则 ，<code>m_userName</code></li><li>常量全部使用大写，多个单词用<code>_</code> 分割，<code>MAX_NUMBER</code></li></ul><h4 id="作用域">作用域</h4><p>局部变量不宜和全局的变量重名，嵌套的块，内部的不要和外部的重名。</p><h2 id="复合类型">3. 复合类型</h2><p>一条声明语句由一个 <strong>基本数据类型</strong> 和紧随其后的一个<strong>声明符</strong> 列表组成。</p><h3 id="引用">3.1 引用</h3><p><strong>引用</strong> 就是为变量（对象）起一个别名</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> val = <span class="hljs-number">1024</span>;<br><span class="hljs-type">int</span> val1 = <span class="hljs-number">102</span>;<br><span class="hljs-type">int</span>&amp; refVal = val;<span class="hljs-comment">//refVal指向val</span><br>refVal = val1;<span class="hljs-comment">//refVal引用并没有改变，只是改变了refVal指向的变量val的值，val = val1</span><br><span class="hljs-type">int</span> &amp;refVal2;<span class="hljs-comment">//错误，引用必须初始化</span><br></code></pre></td></tr></table></figure><blockquote><p>注意:</p><ol type="1"><li>引用只能绑定在对象上，而不能与字面值或表达式计算结果绑定</li><li>引用必须初始化，且不能改变</li><li><code>&amp;</code> 符号可以紧靠基本类型(int), 也可以紧靠变量名</li><li>因为引用本身不是一个对象，所以不能定义引用的引用</li></ol></blockquote><p><strong>以上说的引用都是左值引用，C++11还有右值引用</strong></p><h3 id="指针">3.2 指针</h3><p><strong>指针</strong>就是一个整数，没有实际的数值大小，只是一个编号，这个编号指向的是内存中的某个地址。</p><p>指针 vs 引用：</p><ul><li>指针本身是一个对象没允许对指针赋值和拷贝</li><li>在指针的生命周期内它可以先后指向几个不同的对象</li><li>指针无需在定义时赋值<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="但建议定义时初始化，如果没有想好指向哪个变量，可以初始化为空指针。">[1]</span></a></sup></li></ul><p>指针的定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> *p1, *p2;<span class="hljs-comment">//p1, p2都是指针类型， 定义在一条语句中，每个变量都要加 *</span><br></code></pre></td></tr></table></figure><blockquote><p>指针无论定义成什么基本类型，其值都是一个固定位数的整数，指针类型数据的大小取决于系统的位数</p><p>32bit的系统指针是4byte = 32 bit, 64 bit系统指针式 8 byte = 64bit</p></blockquote><p>指定类型的指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> val = <span class="hljs-number">102</span>;<br><span class="hljs-type">int</span> *p = &amp;val;<span class="hljs-comment">//指针p指向val变量的内存地址</span><br></code></pre></td></tr></table></figure><blockquote><p>定义指定类型的指针只是为了提供操作数据时需要操作的字节数。</p><p>例如，<code>int</code>型的指针，在使用指针改变指向的数据时，改变的是以该指针变量为首地址的4个字节内存，</p><p>同样对<code>int</code>型指针的加或减的操作也是以4个字节为基本单位</p></blockquote><p><code>*</code>(解引用符) 和 <code>&amp;</code>(取地址符)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> val = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> *p = <span class="hljs-literal">nullptr</span>;  <span class="hljs-comment">//* 表示定义一个指针变量，并且初始化为空指针，等价于 int *p = 0</span><br>p = &amp;val;<span class="hljs-comment">//&amp; 表示取val变量的地址值</span><br>std::cout &lt;&lt; *p &lt;&lt; std::endl;<span class="hljs-comment">//* 表示解引用，取出p地址指向的值，即 val</span><br></code></pre></td></tr></table></figure><p>赋值和指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> val = <span class="hljs-number">42</span>;<br><span class="hljs-type">int</span> *p = <span class="hljs-number">0</span>;<br>p = &amp;val; <span class="hljs-comment">//p的值被改变，现在p指向了val</span><br>*p = <span class="hljs-number">0</span>;   <span class="hljs-comment">//val的值被改变，指针p并没有改变</span><br></code></pre></td></tr></table></figure><blockquote><p>指针使用建议：</p><ol type="1"><li>指针定义是可以不初始化，但建议定义时初始化，如果没有想好指向哪个变量，可以初始化为空指针</li><li>操作指针时，须确定操作的不是空指针和野指针（无效指针）</li></ol></blockquote><h3 id="理解复合类型的声明">3.3 理解复合类型的声明</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i = <span class="hljs-number">42</span>;<br><span class="hljs-type">int</span> *p;<span class="hljs-comment">//p是int型的指针</span><br><span class="hljs-type">int</span> *&amp;r = p;<span class="hljs-comment">//r是一个对int型指针p的引用</span><br><br>r = &amp;i;<span class="hljs-comment">//r是一个指针引用，因此给r赋值&amp;i就是令p指向i</span><br>*r = <span class="hljs-number">0</span>;<span class="hljs-comment">//解引用r,就是解引用指针p,将p指向的变量i的值改为0</span><br></code></pre></td></tr></table></figure><blockquote><p>Tip:面对一条比较复杂的指针或引用的声明语句时，<strong>从右向左</strong>读有助于弄清楚它的真实含义。</p><p>离变量名最近的符号（此例中是&amp;r的符号&amp;）对变量的类型有最直接的影响，因此 r 是一个引用。声明符的其余部分用以确定 r 引用的类型是什么，此例中的符号*说明r 引用的是一个指针。最后，声明的基本数据类型部分指出 r 引用的是一个 int指针 。</p></blockquote><h2 id="const-限定符">4. const 限定符</h2><p>const 用于定义一个不能改变的变量, 所以定义时就必须初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">cont <span class="hljs-type">int</span> bufSize = <span class="hljs-number">512</span>;<span class="hljs-comment">//用字面值常量初始化</span><br>cont <span class="hljs-type">int</span> i = <span class="hljs-built_in">get_size</span>();<span class="hljs-comment">//用函数返回值初始化， 运行时初始化</span><br><span class="hljs-type">int</span> j = <span class="hljs-number">10</span>;<br>cont <span class="hljs-type">int</span> k = j;<span class="hljs-comment">//用其他变量初始化</span><br></code></pre></td></tr></table></figure><blockquote><p><code>const</code> 定义的变量只对本文件可见，要使其他文件也可见需使用<code>extern</code></p></blockquote><h3 id="const的引用">4.1 const的引用</h3><ul><li><p><strong>对常量的引用不能被用作修改它所绑定的对象</strong></p></li><li><p><strong>允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式</strong>==此时常量引用实际上绑定了一个临时量对象==</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i = <span class="hljs-number">42</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> j = <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;r1 = i;<span class="hljs-comment">//正确，允许将 const int&amp;绑定到一个普通int对象</span><br>r1 = <span class="hljs-number">10</span>;<span class="hljs-comment">//错误，不能通过常量引用改变i的值</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;r2 = <span class="hljs-number">42</span>;<span class="hljs-comment">//正确</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;r3 = r1 * <span class="hljs-number">2</span>;<span class="hljs-comment">//正确</span><br><span class="hljs-type">int</span>&amp; r4 = j;<span class="hljs-comment">//错误</span><br><span class="hljs-type">int</span> &amp;r4 = r1 * <span class="hljs-number">2</span>;<span class="hljs-comment">//错误</span><br></code></pre></td></tr></table></figure><p>==组合关系==</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;"><code>int i</code></th><th style="text-align: center;"><code>cont int i</code></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>int &amp;r</code></td><td style="text-align: center;">✔</td><td style="text-align: center;">❌</td></tr><tr class="even"><td style="text-align: center;"><code>cont int &amp;r</code></td><td style="text-align: center;">✔</td><td style="text-align: center;">✔</td></tr></tbody></table><h3 id="指针和const">4.2 指针和const</h3><p>指向常量的指针和对常量的引用类似：</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;"><code>int i</code></th><th style="text-align: center;"><code>cont int i</code></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>int *p</code></td><td style="text-align: center;">✔</td><td style="text-align: center;">❌</td></tr><tr class="even"><td style="text-align: center;"><code>cont int *p</code></td><td style="text-align: center;">✔</td><td style="text-align: center;">✔</td></tr></tbody></table><blockquote><p>Tip:所谓指向常量的指针或引用，不过是指针或引用“自以为是”罢了，它们觉得自己指向了常量，所以自觉地不去改变所指对象的值。</p></blockquote><h4 id="常量指针">常量指针</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> errNumb = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> *<span class="hljs-type">const</span> curErr = &amp;errNumb;<span class="hljs-comment">//curErr将一直指向errNumb,不可以改变指向</span><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> pi = <span class="hljs-number">3.14</span>;<br>cont <span class="hljs-type">double</span> *<span class="hljs-type">const</span> pip = &amp;pi;<span class="hljs-comment">//pip是一个指向常量对象的常量指针</span><br>*curErr = <span class="hljs-number">1</span>;  <span class="hljs-comment">//正确，把curErr所指的对象的值设为1</span><br>*pip = <span class="hljs-number">2.72</span>;  <span class="hljs-comment">//错误，pip是一个指向常量的指针</span><br></code></pre></td></tr></table></figure><p>==<strong>从右向左读</strong>==</p><blockquote><p>C++ Primer 5th :</p><p><a id="const point">常量指针</a>：该变量是一个指针，指针本身是一个常量，即它的指向初始化后不可以改变</p></blockquote><h3 id="顶层const">4. 3 顶层const</h3><p><strong>顶层const</strong> :表示该变量（对象）本身是常量，不可以改变</p><p><strong>底层const</strong>: 表示指向的变量（对象）是一个常量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> *<span class="hljs-type">const</span> p1 = &amp;i;<span class="hljs-comment">//p1是指针，p1的指向不能改变，顶层</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> ci = <span class="hljs-number">42</span>;<span class="hljs-comment">//ci是普通变量，ci的值不能改变，顶层</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *p2 = &amp;ci;<span class="hljs-comment">//p2是一个指针，它必须指向 const int型的数据，但是本身的指向可以改变，底层</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *<span class="hljs-type">const</span> p3 = p2;<span class="hljs-comment">//第一个底层，第二个顶层</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;r = ci;<span class="hljs-comment">//用于声明引用的const都是底层</span><br></code></pre></td></tr></table></figure><p>==引用类型的变量自带顶层const==即引用一旦赋值（指向某个变量）就不可以再变化（指向另一个变量）</p><h3 id="constexpr和常量表达式">4.4 constexpr和常量表达式</h3><p>指值不会改变并且在编译过程就能得到计算结果的表达式。</p><p><strong>constexpr和指针</strong></p><blockquote><p>一个constexpr指针的初始值必须是nullptr或者0,或者是存储于某个固定地址中的对象</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> *p1 = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> *p2 = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-type">int</span> *<span class="hljs-type">const</span> p3 = <span class="hljs-literal">nullptr</span>;<br></code></pre></td></tr></table></figure><blockquote><p>p2和p3是等价的，<code>constexpr</code>修饰指针变量是被定义为顶层const</p></blockquote><h2 id="处理类型">5. 处理类型</h2><p>为了复杂程序更加易读易写，通常会给类型取别名，或是利用C++提供的特性自动推导复杂类型。</p><h3 id="类型别名">5.1 类型别名</h3><h4 id="typedef">typedef</h4><p>传统的方法是使用 <code>typedef</code> 关键字定义类型别名</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">double</span> wages;<span class="hljs-comment">//wages表示是double类型</span><br><span class="hljs-keyword">typedef</span> wages base, *p;<span class="hljs-comment">//base = wages = double, p = double*</span><br><span class="hljs-comment">//数组的别名</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> arrT[<span class="hljs-number">10</span>];<span class="hljs-comment">//arrT是一个类型别名，他表示的类型是含有10个整数的数组</span><br><span class="hljs-keyword">using</span> arrT = <span class="hljs-type">int</span>[<span class="hljs-number">10</span>];<span class="hljs-comment">//和上面的等价</span><br></code></pre></td></tr></table></figure><h4 id="using">using</h4><p><span style="border:2px solid Red">C++11</span>提供了一种新的方式，使用 <code>using</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> SI = Sales_item;<span class="hljs-comment">//Sales_item是一个类类型， SI表示是该类的别名</span><br></code></pre></td></tr></table></figure><blockquote><p>这里的 <code>using</code> 要和 <code>using namespace std;</code> 中的<code>using</code>区分开。后者是表示引入命名空间，类似于java和python的导包操作</p></blockquote><h4 id="指针常量和类型别名">指针、常量和类型别名</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span>* pstring;<br><span class="hljs-type">const</span> pstring cstr = <span class="hljs-number">0</span>;<span class="hljs-comment">//char *const cstr = 0;</span><br><span class="hljs-type">const</span> pstring *ps;<span class="hljs-comment">//char **const ps;</span><br></code></pre></td></tr></table></figure><p><strong>第二行的定义不能理解成 <code>const char *cstr = 0;</code></strong></p><blockquote><p><code>const pstring</code> 中 <code>const</code> 是对<code>pstring</code> 的修饰，而 <code>pstring</code> 是一个<code>char*</code> 类型，因此 <code>const pstring</code> 是指向 char的<a href="#const%20point">常量指针</a> ，而并不是指向常量字符的指针</p></blockquote><h3 id="auto-类型说明符">5.2 auto 类型说明符</h3><p><span style="border:2px solid Red">C++11</span> <code>auto</code>类型说明符可以让编译器分析表达式所属的类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> val1 = <span class="hljs-number">1</span>, val2 = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">auto</span> val = val1 + val2;<span class="hljs-comment">//编译器可以自动推出val为int类型</span><br><span class="hljs-keyword">auto</span> i = <span class="hljs-number">0</span>, *p = &amp;i;<span class="hljs-comment">//正确，编译器通过字面值推出i为int,p为int*</span><br><span class="hljs-keyword">auto</span> sz = <span class="hljs-number">0</span>; pi = <span class="hljs-number">3.14</span>;<span class="hljs-comment">//错误，编译器无法推出类型， sz， pi类型不一致无法统一</span><br></code></pre></td></tr></table></figure><h4 id="复合类型常量和auto">复合类型、常量和auto</h4><ul><li><p>当使用引用类型推导类型时，<code>auto</code>推导的类型是引用指向变量的实际类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; &amp;r = i;<br><span class="hljs-keyword">auto</span> a = r;<span class="hljs-comment">// r是int型的引用,因此a是int型</span><br></code></pre></td></tr></table></figure></li><li><p><code>auto</code>会忽略掉顶层const, 同时底层const则会保留下来</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> ci = i, &amp;cr = ci;<br><span class="hljs-keyword">auto</span> b = ci;<span class="hljs-comment">//int b = ci;</span><br><span class="hljs-keyword">auto</span> c = cr;<span class="hljs-comment">//int c = cr;  cr是ci的别名，ci本身是一个顶层const</span><br><span class="hljs-keyword">auto</span> d = &amp;i;<span class="hljs-comment">//int *d = &amp;i;</span><br><span class="hljs-keyword">auto</span> e = &amp;ci;<span class="hljs-comment">//const int *e = &amp;ci; 对常量对象取地址是一种底层const</span><br></code></pre></td></tr></table></figure><p>如果希望推断出的auto类型是一个顶层const，需要明确指出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> f = ci;<span class="hljs-comment">// const int f = ci;</span><br></code></pre></td></tr></table></figure><p>指定引用类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> &amp;g = ci;<span class="hljs-comment">//const int &amp;g = ci;</span><br><span class="hljs-keyword">auto</span> &amp;h = <span class="hljs-number">42</span>;<span class="hljs-comment">//错误，int &amp;h = 42;</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;j = <span class="hljs-number">42</span>; <span class="hljs-comment">//const int &amp;j = 42;</span><br></code></pre></td></tr></table></figure></li></ul><blockquote><p>auto 使用建议：</p><p>使用auto声明变量一定要做到心里有数，你知道编译器会推断出的什么样的类型</p><p>通常使用auto是对于一些类型名比较复杂的变量，使用auto写起来更方便</p></blockquote><h3 id="decltype-类型指示符">5.3 decltype 类型指示符</h3><p><span style="border:2px solid Red">C++11</span> <code>decltype</code>可以不执行表达式，编译器自动推断出表达式的返回值类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">f</span>()) sum = x;<span class="hljs-comment">//sum的类型和f()的返回类型一样</span><br></code></pre></td></tr></table></figure><p>通过 <code>f()</code> 推断出返回类型，但是并不会执行<code>f()</code></p><h4 id="decltype-和const">decltype 和const</h4><p><code>decltype</code>处理顶层 consth和引用的方式和auto有点不同，如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（==包括顶层const和引用在内==）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> ci = <span class="hljs-number">0</span>, &amp;cj = ci;<br><span class="hljs-keyword">decltype</span>(ci) x = <span class="hljs-number">0</span>;<span class="hljs-comment">//const int x = 0</span><br><span class="hljs-keyword">decltype</span>(cj) y = <span class="hljs-number">0</span>;<span class="hljs-comment">//const int &amp;y = 0;</span><br><span class="hljs-keyword">decltype</span>(cj) z;<span class="hljs-comment">//错误， const int &amp;z;  引用必须初始化</span><br></code></pre></td></tr></table></figure><h4 id="decltype-和引用">decltype 和引用</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> i = <span class="hljs-number">42</span>, *p = &amp;i, &amp;r = i;<br><span class="hljs-keyword">decltype</span>(r + <span class="hljs-number">0</span>) b;<span class="hljs-comment">//int b;</span><br><span class="hljs-keyword">decltype</span>(*p) c;<span class="hljs-comment">//错误， int &amp;c; 引用需要初始化</span><br></code></pre></td></tr></table></figure><blockquote><p><code>r</code> 是引用 <code>decltype(r)</code> 是引用，但是<code>r + 0</code> 是一个int型数据</p><p>解引用指针得到的是指针所指的对象，，因此 <code>decltype(*p)</code> 是<code>int&amp;</code></p></blockquote><p>变量加上 <code>()</code> 得到的是引用类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">decltype</span>((i)) d;   <span class="hljs-comment">//错误， int&amp; d; 引用类型需要初始化</span><br><span class="hljs-keyword">decltype</span>(i) e;<span class="hljs-comment">// int e;</span><br></code></pre></td></tr></table></figure><p>==<code>decltype((variable))</code> 的结果永远是引用==</p><h2 id="自定义数据结构">6. 自定义数据结构</h2><p>这里的自定义数据结构就是指类类型的数据，在C++中定义类的关键字有<code>class</code>和 <code>struct</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassName</span>&#123;<br><span class="hljs-comment">//属性</span><br><span class="hljs-comment">//方法</span><br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ClassName</span>&#123;<br><span class="hljs-comment">//属性</span><br><span class="hljs-comment">//方法</span><br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p><code>class</code> 和 <code>struct</code>在功能上是完全一样的，两者唯一的不同是默认的权限不同</p><p><code>class</code>默认的权限是私有的(private), 而 <code>struct</code>是公有的(public)</p></blockquote><p><em>注意：c语言中的结构体是不能有方法（函数）</em></p><p>关于类更具体的介绍在后面的章节~~</p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>但建议定义时初始化，如果没有想好指向哪个变量，可以初始化为空指针。<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++ Primer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CCLF(基于内容连接度和位置感知的自适应转发)</title>
    <link href="/2023/04/15/20230415-CCLF/"/>
    <url>/2023/04/15/20230415-CCLF/</url>
    
    <content type="html"><![CDATA[<h2 id="information">Information:</h2><ol type="1"><li>Title: Leveraging Content Connectivity and Location Awareness forAdaptive Forwarding in NDN-based Mobile Ad Hoc Networks(基于内容连接性和位置感知的NDN移动自组织网络自适应转发技术)</li><li>Authors: Muktadir Chowdhury, Junaid Ahmed Khan, and Lan Wang</li><li>Affiliation: University of Memphis (孟菲斯大学)</li><li>Keywords: Named Data Networking, MANET, routing, forwarding(命名数据网络，移动自组织网络，路由，转发)</li><li>Urls: Paper link: https://dl.acm.org/doi/10.1145/3405656.3418713,Github: None.</li></ol><h2 id="summary">Summary:</h2><ul><li>(1):本文研究了移动自组织网络（MANETs）中的数据转发问题，提出了基于命名数据网络（NDN）的内容连接性和位置感知的自适应转发策略。</li><li>(2):传统的MANET转发策略在高度动态的网络中很难有效转发数据，并且在存在连接变化时通常需要大量控制报文来获取拓扑信息。本文提出的方法是<strong>基于内容连接性和位置信息</strong>对数据进行转发，避免了控制报文的开销，并且通过在网络层维护转发状态和期望转发反馈来加强转发策略的适应性。</li><li>(3): 文中提出了一个自适应转发策略——Content Connectivity andLocation-Aware Forwarding(CCLF)，在NDN网络中进行转发时基于内容连接性和位置信息，避免了控制报文和数据报文之间的不一致，并且通过减少无效广播来提升转发性能。此外还提出了适用于MANET网络的链路自适应层（A-LAL）以增强链路的灵活性和可靠性。</li><li>(4):研究结果表明，CCLF能够有效降低数据转发的负载并保证数据的可靠获取，在信息中心化车联网方案中也比其他转发策略表现更为优异，验证了其在移动自组织网络中的有效性。</li></ul><h2 id="method">Method:</h2><p>CCLF广播NDN数据包，让每个节点根据每个前缀的内容连接度和任何可用的地理位置信息独立地决定是否转发数据包；此外，它采用密度感知的抑制机制来减少不必要的包传输；此外，为adhoc链路开发了链路适配层，以弥合CCLF与底层链路能力之间的差距。</p><h3 id="内容连接度">内容连接度</h3><p>内容连接度是<strong>细粒度</strong>的，区分于以往基于节点的整体兴趣满意度来量化节点的连通性，CCLF对<strong>每一个名称前缀</strong>分别计算一个内容连通性分数(ContentConnectivity Score, CCS)。</p><blockquote><p>This fine-grained measure of forwarding performance helps the networklayer make more informed decisions when forwarding Interests to retrievedata from different producers.</p></blockquote><p>CCS计算公式： <span class="math display">\[CCS_j = \frac{D_j+\sum_{i\in Desc(j)}D_i}{I_j+\sum_{i\in Desc(j)}I_i}\]</span> <span class="math inline">\(D_j,I_j\)</span>分别表示对应前缀<span class="math inline">\(j\)</span>的Data、Interest个数，<span class="math inline">\(Desc(j)\)</span>表示前缀<span class="math inline">\(j\)</span>的子类的集合。</p><p>CCS周期性更新，根据指数加权移动平均(EWMA): <span class="math display">\[\widehat{CCS}_{i,N}=\alpha \cdot CCS_{i,N}+(1-\alpha) \cdot\widehat{CCS}_{i,N-1}\]</span></p><h3 id="地理位置">地理位置</h3><p>地理位置在CCLF中作为<strong>可选项</strong>使用，Consumer可以将数据的位置附加到Interest中（<em>通过NDNLP header</em>）,节点接收到此类Interest后，计算位置分数（LocationScore,LS）: <span class="math display">\[LS = 1- \frac{Dist(n,d)}{max(Dist(n,d),Dist(p,d))}\]</span> <span class="math inline">\(p,n,d\)</span>分别代表上一跳、当前、目的节点。</p><p>CCS和位置信息通过新设定的C-L tree结构来储存、更新与检索： <img src="/2023/04/15/20230415-CCLF/1681475432881.png" alt="C-L tree"></p><h3 id="转发计时器">转发计时器</h3><p>和其他策略类似，当某个节点通过其广播链路发送Interest后，传输范围内的其他节点分布式决定<strong>是否以及何时</strong>转发该兴趣。首先对CCS和LS加权： <span class="math display">\[w = \beta \cdot \widehat{CCS} + (1-\beta) \cdot LS\]</span> 再取倒数计算基本的定时器时间t: <span class="math display">\[t= \begin{cases}\min \left(\frac{1}{w}, T\right), &amp; \text { if }w&gt;0 \\ T, &amp; \text { if } w=0\end{cases}\]</span> T为t的一个上界，最终定时器的值在<span class="math inline">\(0.5t-1.5t\)</span>之间随机选取。</p><h3 id="密度感知的转发抑制">密度感知的转发抑制</h3><p>当节点在某个Interest的转发计时器到期之前收到相同Interest时，它使用一个<strong>与其邻居数量成正比的抑制概率</strong>来决定是否取消自己的兴趣转发：<span class="math display">\[p=min(K \cdot n, 1)\]</span><em>Data包也采用相同的概率抑制方案，不过在Data包转发中，节点的Timer值是相同的。</em></p><h3 id="ad-hoc链路适配层">AD-HOC链路适配层</h3><p>开发了新的一个Ad-hoc Link AdaptationLayer(A-LAL)层面，为CCLF提供一些重要操作：</p><figure><img src="/2023/04/15/20230415-CCLF/1681479229022.png" alt="A-LAL"><figcaption aria-hidden="true">A-LAL</figcaption></figure><ul><li>在Interes包中添加NDNLP头(previous hop location和data location)</li><li>利用MAC层的信息来跟踪邻居节点的数量(Neighbor-List)，以支持转发抑制概率的计算</li><li>没有邻居节点时，存储包(PacketQueue)直至发现邻居</li></ul><p>最后，总的转发流程伪代码如下： <img src="/2023/04/15/20230415-CCLF/1681480197163.png" alt="Interest转发"></p><figure><img src="/2023/04/15/20230415-CCLF/1681480213422.png" alt="Data包转发"><figcaption aria-hidden="true">Data包转发</figcaption></figure><h2 id="conclusion">Conclusion:</h2><ul><li>(1):本文提出了一种基于内容连接性和位置感知的自适应转发策略，CCLF，用于解决移动自组织网络（MANETs）中的数据转发问题，具有实际应用价值。</li><li>(2):创新点：本文提出的CCLF算法在转发决策中加入了内容连接性和位置信息，可以有效地避免控制报文开销和数据报文不一致问题，并减少无效广播，具有较高的性能表现。但是本文研究还存在一定的局限性，需要进一步拓展研究范围，对算法的参数调整及不同情境的适用性进行更深入的研究，并进行更全面的评估测试。</li><li>性能：CCLF相较于传统的转发策略，在满足数据转发的负载要求的同时减少了数据转发的开销，具有较高的性能表现。</li><li>工作量：本文的研究范围相对狭窄，需要进一步的实验和评估工作以证明其普适性和适用性。</li></ul>]]></content>
    
    
    <categories>
      
      <category>论文阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NDN</tag>
      
      <tag>Ad hoc</tag>
      
      <tag>转发</tag>
      
      <tag>地理位置</tag>
      
      <tag>可靠性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ad Hoc</title>
    <link href="/2023/03/31/20230323/"/>
    <url>/2023/03/31/20230323/</url>
    
    <content type="html"><![CDATA[<h2 id="汪浩东周报">20230323汪浩东周报</h2><p>本周主要对于AdHoc中的相关问题进行了更深的思考，以期找到其（包括无线场景）的问题，尤其是在与NDN相结合的方面，因为经过小组讨论认为，目前我们仍未搞清楚将大背景移到无线场景下时，会有什么不同以及新的问题的来源及解决方案。</p><h3 id="ad-hoc无线场景下的问题以广播风暴为例">AdHoc(无线)场景下的问题（以广播风暴为例）</h3><p>首先是这个大的背景问题，对于无线以及AdHoc这个新场景，其所面临的问题我们始终没有理清楚，以广播风暴为例。</p><p>首先，在无线AdHoc网络中，因为没有有线连接的支持，以及无线信道的有损性（在Adhoc中还需要考虑移动性），因此一般采用广播的方式传输包，注意，此处的广播指的是数据链路层，即使用共享广播信道，让所有主机接收同样的包。而这样的广播方式将会带来以下三个问题：#### 冗余对于冗余这个概念，之前我的理解是：“多个主机对相同的包都进行了广播，从而导致了冗余”，但实际上这个理解是错误的，其真正含义应该为：&gt;<strong><em>“当主机决定将收到的广播消息再次广播给邻居时，它的邻居实际上已经拥有了该消息”</em></strong></p><p>即它的邻居实际上已经收到了来自于其他主机的相同广播消息，再次广播是不必要的，因此称其为<strong><em>“冗余”</em></strong>。具体以下图来说明：<img src="/2023/03/31/20230323/OneDrive%20-%20USTC\mySVN\Whd\Md\assets\广播冗余.png" alt="广播冗余">如图所示，B在A的通信范围内，当B收到A的广播消息后，如果其决定再次广播，则能受益的区域（即没有被A广播到的区域）面积为：<span class="math display">\[\text{EAC}=|S_{B-A}| = |S_A|-|S_{A \cap B}| = \pi r^2 - \text{INTC}(d)= \pi r^2 - 4 \int_{d/2}^{r} \sqrt{r^2-x^2}\]</span> 当<span class="math inline">\(d=r\)</span>时，上式取得最大值，但也仅为<span class="math inline">\(0.61\pir^2\)</span>，考虑一般情况，假设B随机处于A的通信范围内任意位置，则可求得EAC的均值为：</p><p><span class="math display">\[ \int_0^r \frac{2\pi x \cdot [\pi r^2 -\text{INTC}(x)]}{\pi r^2} dx \approx 0.41\pi r^2\]</span></p><p>再次将场景扩展，考虑在一个主机的通信范围内存在多个主机的情况下，则相应的再次广播能够带来的额外覆盖率EAC比例与主机数<span class="math inline">\(k\)</span>的关系如下图所示： <img src="/2023/03/31/20230323/OneDrive%20-%20USTC\mySVN\Whd\Md\assets\1679580193476.png" alt="1679580193476"></p><p>由图可见，当<span class="math inline">\(k\)</span>超过4之后，再次广播所带来的额外覆盖增益已经低于<span class="math inline">\(0.05\%\)</span>，即此时再次广播明显是冗余的。[^Note][^Note]:对于并不处于通信范围内的多个主机，当其收到相同广播消息并且向同一节点进行再次广播操作时，这是有必要的，因为可以提升下一节点收到消息的概率，这便体现出了原来的理解的错误之处。</p><h4 id="争用">争用</h4><p>争用实际上应当是广播风暴在Adhoc中最为致命的一点。如前所述，在广播操作中，多个主机实际上是共享相同的广播信道，因此当多个主机同时想要进行广播操作时，就会产生争用问题。</p><p>以两个主机为例，假设B和C都接收到了A的广播消息，则只有当C处于<span class="math inline">\(S_{A\cap B}\)</span>区域时，会发生争用，其概率为：<span class="math display">\[\int_0^r \frac{2 \pi x \cdot text{INTC}(x)/\pi r^2}{\pi r^2}dx \approx 59\%\]</span>当此场景扩展到A的通信范围内有<span class="math inline">\(n\)</span>个主机，则有<span class="math inline">\(k\)</span>个主机在重播时没有发生争用的概率如图所示：<img src="/2023/03/31/20230323/OneDrive%20-%20USTC\mySVN\Whd\Md\assets\1679582024824.png" alt="1679582024824"> 由图可见，当<span class="math inline">\(n \geq6\)</span>时，所有主机都经历争用的概率<span class="math inline">\(cf(n,0)\)</span>已经超过0.8。</p><h4 id="冲突">冲突</h4><p>首先，是CSMA/CA协议，区别于有限局域网中的CSMA/CD协议，在无线环境中，采用的是CA(collisionavoidance)，而非CD(collisiondetection)。无论CSMA/CA还是CSMA/CD，其思想都来源于CSMA(Carrier SenseMultiple Access)，而CSMA实际上来源于Aloha，Aloha的思想可以概括如下：</p><blockquote><p>一个aloha节点只要有数据的话，该节点就可以立即发送。当该节点数据发送完之后，其需要等待接收方反馈的ACK。若成功接收到ACK之后，那么这一次传输成功。如果没有收到ACK的话，那么这一次传输失败。该aloha节点会认为网络中还存在另外一个aloha节点也在发送数据，所以造成接收方发生了冲突。最后这些冲突的节点会随机选择一个时间进行退避（backoff），以避免下一次冲突。若冲突节点回退完成，其才可以重新进行发送。</p></blockquote><p>而CSMA相对与Aloha，增添了LBT(listen before talk)机制，即：</p><blockquote><p>CSMA节点在每一次发送之前先监听信道是否是空闲的，如果信道不是空闲的话，那么就不发送数据，等待一会再进行尝试。只有确保是空闲的情况下，才可以发送数据，从而避免打断其他节点正在进行的传输过程。</p></blockquote><p>其可以分为三种模式<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Difference between 1-persistent, p-persistent and Non-persistent CSMA - GeeksforGeeks](https://www.geeksforgeeks.org/difference-between-1-persistent-p-persistent-and-non-persistent-csma/)">[1]</span></a></sup>：</p><ul><li>1-persistentesCSMA：“<strong>节点需要持续监听信道，一旦节点发现信道空闲后，则立刻发送数据。</strong>”</li><li>0-persistentesCSMA：“<strong>节点不连续监听信道，若该时刻节点监听信道为busy，那么等待一段时间后，再次进行监听。若节点该时刻监听信道为空闲，则立刻发送数据。</strong>”</li><li>p-persistentesCSMA：“<strong>节点需要持续监听信道，一旦发现信道空闲后，节点以p的概率立刻发送数据，以1-p的概率不发送数据。若节点该时刻不发送数据，那么等待一段时间后，再次进行监听，并以p概率再次发送</strong>”。</li></ul><p>在以上三种CSMA机制中，若节点传输发送冲突，则类似aloha的基本算法，随机等待一个时间之后，再次进行重试。接下来便可以进一步探讨CSMA/CD与CSMA/CA。</p><p>在思想上，CSMA/CD类似于1-persistentesCSMA，而CSMA/CA类似于p-persistentesCSMA，即CSMA/CD是持续监听信道，一旦监听到空闲立刻发生数据，在发送数据时依然检测信道是否有冲突，如果有冲突就停止发送并等待一段随机时间后重试；CSMA/CA是在发送数据前检测信道是否空闲，如果空闲则对backoffcounter进行减一操作，直至counter为零才可以发送数据并等待确认帧，如果不空闲则挂起counter，等待一段随机时间后重试。两者的对比可参见<a href="https://www.geeksforgeeks.org/difference-between-csma-ca-and-csma-cd/?ref=rp">Differencebetween CSMA/CA and CSMA/CD - GeeksforGeeks</a>、<a href="https://www.geeksforgeeks.org/carrier-sense-multiple-access-csma/">CarrierSense Multiple Access (CSMA) - GeeksforGeeks</a></p><p>知道了两者的不同之后，产生了一个新问题：为什么在无线环境下不再执行CD，而是需要更改为CA？</p><p>在有线网络中，如果发生冲突，站点可以通过接收信号的能量变化来检测到冲突。因此，它们可以立即停止发送并等待一段随机时间后再重试，这样可以减少冲突的可能性和浪费的带宽。而在无线网络中，由于信号能量的变化很小，站点很难检测到冲突。因此，它们需要等待整个数据包发送完毕后才能知道是否发生了冲突。这样会导致更多的带宽浪费和延迟。所以，在无线网络中，冲突避免更加重要和必要。</p><h4 id="隐藏终端和暴露终端">隐藏终端和暴露终端</h4><p>在无线环境下，还有两个很重要的问题，即隐藏终端和暴露终端，如下面两张图所示。<img src="/2023/03/31/20230323/OneDrive%20-%20USTC\mySVN\Whd\Md\assets\隐蔽站和暴露站.png"></p><p>对于隐藏终端问题，可以通过RTS/CTS机制来解决：在发送数据之前，站点先发送一个请求发送（RTS）的信号给接收站点，接收站点回复一个清除发送（CTS）的信号给发送站点和其他邻近站点。这样，其他邻近站点就知道有一个正在进行的传输，并且等待一段时间后再尝试发送，这种方式可以有效地减少隐藏终端问题造成的冲突和带宽浪费。</p><p>但需要注意的是，RTS/CTS机制在IEEE802.11协议中是可选项而非必选项，因为如果 A正在向 B发送一个小数据包，那么对于A来说，简单地发送数据包并准备好在它受到干扰时重新发送，比试图阻止这种干扰要便宜得多。</p><p><strong>以上所讨论的都是一对一的情况，实际上在802.11中不考虑一对多的情况</strong></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.geeksforgeeks.org/difference-between-1-persistent-p-persistent-and-non-persistent-csma/">Differencebetween 1-persistent, p-persistent and Non-persistent CSMA -GeeksforGeeks</a><a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>第3章 字符串、向量和数组</title>
    <link href="/2023/02/08/Ch3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/"/>
    <url>/2023/02/08/Ch3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="第3章-字符串向量和数组">第3章 字符串、向量和数组</h1><h2 id="命名空间的using声明">1. 命名空间的using声明</h2><p>在前面的示例程序中，输入和输出都是写成 <code>std::cin</code> ,<code>std::cout</code> , 我们可以在使用前使用 <code>using</code>声明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> std::cin;<br><span class="hljs-keyword">using</span> std::cout; <span class="hljs-keyword">using</span> std::endl;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> v1, v2;<br>    cin &gt;&gt; v1 &gt;&gt; v2;<br>    cout&lt;&lt;<span class="hljs-string">&quot;Ths sum is&quot;</span>&lt;&lt; v1 + v2 &lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>一行可放多条using声明语句，但每个名字都需要独立的using声明。</strong></p><blockquote><p>实际更常见的做法是使用 <code>using namespace std;</code>把整个命名空间都引入，这样std命名空间下的成员都可以使用了。</p><p>注意：头文件中尽量不要引入整个命名空间，因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件里有某个using 声明，那么每个使用了该头文件的文件就都会有这个声明，这样可能会和自己写的一些类名冲突。</p></blockquote><h2 id="标准库类型-string">2. 标准库类型 string</h2><p><code>string</code>表示可变长的字符序列，<code>string</code>的使用需要包含一个头文件和命名空间</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br></code></pre></td></tr></table></figure><h3 id="定义和初始化string对象">2.1 定义和初始化string对象</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">string s1;<span class="hljs-comment">//默认初始化， s1是一个空串</span><br><span class="hljs-function">string <span class="hljs-title">s2</span><span class="hljs-params">(s1)</span></span>;<span class="hljs-comment">//s2是s1的副本</span><br>string s2 = s1;    <span class="hljs-comment">//等价于s2(s1),s2是s1的副本</span><br><span class="hljs-function">string <span class="hljs-title">s3</span><span class="hljs-params">(<span class="hljs-string">&quot;value&quot;</span>)</span></span>; <span class="hljs-comment">//直接初始化，s3是字面值&quot;value&quot;                       的副本，不包含最后的空字符</span><br>string s3 = <span class="hljs-string">&quot;value&quot;</span>; <span class="hljs-comment">//拷贝初始化，s3是字面                                值“vale&quot; 的副本</span><br><span class="hljs-function">string <span class="hljs-title">s4</span><span class="hljs-params">(n, <span class="hljs-string">&#x27;c&#x27;</span>)</span></span>;<span class="hljs-comment">//连续n个&#x27;c&#x27;组成的串</span><br></code></pre></td></tr></table></figure><h3 id="string对象上的操作">2.2 string对象上的操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">os &lt;&lt; s;<span class="hljs-comment">//将s写到输出流os中，返回os</span><br>is &gt;&gt; s;<span class="hljs-comment">//从is中读取字符串赋给s,字符串以                       空白分隔，返回is</span><br><span class="hljs-built_in">getline</span>(is, s);<span class="hljs-comment">//从is中读取一行赋给s,返回is</span><br>s.<span class="hljs-built_in">empty</span>();<span class="hljs-comment">//s为空返回true，否则返回false</span><br>s.<span class="hljs-built_in">size</span>();<span class="hljs-comment">//返回s中字符的个数</span><br>s[n];<span class="hljs-comment">//返回s中第n个字符的引用，位置从0                       开始</span><br>s1 + s2;<span class="hljs-comment">//返回s1和s2连接后的结果</span><br>s1 = s2;<span class="hljs-comment">//用s2的副本代替s1中原来的字符</span><br>s1 == s2;<span class="hljs-comment">//判断是否一致</span><br>s1 != s2;<span class="hljs-comment">//判断是否不一样</span><br>&lt; , &lt;=, &gt;, &gt;=<span class="hljs-comment">//通过字典中的顺序比较，对字母大小                       写敏感</span><br></code></pre></td></tr></table></figure><blockquote><p>size()函数返回的类型是string::size_type</p></blockquote><p>字面值和string对象相加</p><p><strong>当把 <code>string</code>对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保每个加法运算符(+) 的两侧的运算对象至少有一个是<code>string</code></strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">string s1 = <span class="hljs-string">&quot;hello&quot;</span>;<br>string s4 = s1 + <span class="hljs-string">&quot;, &quot;</span>;       <span class="hljs-comment">//正确</span><br>string s5 = <span class="hljs-string">&quot;hello&quot;</span> + <span class="hljs-string">&quot;, &quot;</span>;  <span class="hljs-comment">//错误</span><br>string s6 = s1 + <span class="hljs-string">&quot;, &quot;</span> + <span class="hljs-string">&quot;world&quot;</span>; <span class="hljs-comment">//正确</span><br>string s7 = <span class="hljs-string">&quot;hello&quot;</span> + <span class="hljs-string">&quot;, &quot;</span> + s2;  <span class="hljs-comment">//错误</span><br></code></pre></td></tr></table></figure><blockquote><p>字符串字面值与string是不同的类型</p></blockquote><h3 id="处理string对象中的字符">2.3 处理string对象中的字符</h3><p>在头文件 <code>cctype</code> 中定义了一组相关的函数</p><figure><img src="https://kinvy-images.oss-cn-beijing.aliyuncs.com/Images/image-20211216191219702.png" alt="image-20211216191219702"><figcaption aria-hidden="true">image-20211216191219702</figcaption></figure><blockquote><p><code>cctype</code>是c语言的头文件，在c++中包含c的头文件有两种形式</p><ul><li><code>#include &lt;ctype.h&gt;</code> 和c语言一样</li><li><code>#include &lt;cctype&gt;</code> 不加 <code>.h</code>而是在前面加一个 <code>c</code></li></ul></blockquote><p><strong>基于范围的for语句</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//语法</span><br><span class="hljs-keyword">for</span> (declaration : expression)<br>    statement<br>    <br><span class="hljs-comment">//示例</span><br>string str = <span class="hljs-string">&quot;helloWorld&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> s : str)  <span class="hljs-comment">//使用aotu自动类型推导</span><br>&#123;<br>    cout &lt;&lt; s &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//如果需要改变str中字符，用引用</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;c : str)<br>&#123;<br>    c = <span class="hljs-built_in">toupper</span>(c);<span class="hljs-comment">//c是引用</span><br>&#125;<br>cout &lt;&lt; str &lt;&lt; endl;<br></code></pre></td></tr></table></figure><blockquote><p>基于范围的for，只适用于可迭代的对象</p></blockquote><h2 id="标准库类型-vector">3. 标准库类型 vector</h2><p>标准库类型 vector表示对象的集合，其中所有对象的类型都相同。用vector需要包含下面的头文件和声明命名空间</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> std::vector;<span class="hljs-comment">//或者 using namespace std; 引入std命名空间所有的成员</span><br></code></pre></td></tr></table></figure><p><code>vector</code>类似于数组，但是比数组用于更多的操作。<code>vector</code>是一个模板类，所谓模板就是该类内部中的属性没有指定某种特定的数据类型，我们可以在声明vector时指定数据类型（包括基本类型和自定义类型）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; ivec;<span class="hljs-comment">//ivec时int类型的对象集合</span><br>vector&lt;Sales_item&gt; Sales_vec;<span class="hljs-comment">//Sales_vec是Sales_item类型的对象集合</span><br>vector&lt;vector&lt;string&gt;&gt; file;<span class="hljs-comment">//该向量的元素是vector对象</span><br></code></pre></td></tr></table></figure><h3 id="定义和初始化vector对象">3.1 定义和初始化vector对象</h3><p>定义vector对象的常用方法</p><p><img src="/2023/02/08/Ch3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/1692618512009.png"></p><blockquote><p>注意 <code>()</code> 和 <code>&#123;&#125;</code> 初始化vector对象的区别。</p><p><code>()</code>是用来构造vector对象；<code>&#123;&#125;</code>是列表初始化该对象</p></blockquote><p><strong>如果初始化时使用了花括号的形式但是提供的值又不能用来列表初始化，就要考虑用这样的值来构造vector对象了</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;string&gt; v5&#123;<span class="hljs-string">&quot;hi&quot;</span>&#125;; <span class="hljs-comment">//列表初始化：v5有一个元素</span><br><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">v6</span><span class="hljs-params">(<span class="hljs-string">&quot;hi&quot;</span>)</span></span>; <span class="hljs-comment">//错误：不能使用字符串字面值构建vector对象</span><br>vector&lt;string&gt; v7&#123;<span class="hljs-number">10</span>&#125;;  <span class="hljs-comment">//v7有10个默认初始化的元素</span><br>vector&lt;string&gt; v8&#123;<span class="hljs-number">10</span>,<span class="hljs-string">&quot;hi&quot;</span>&#125;; <span class="hljs-comment">//v8有10个值为&quot;hi&quot;的元素</span><br></code></pre></td></tr></table></figure><h3 id="vector操作">3.2 vector操作</h3><p>vector常用的操作</p><p><img src="/2023/02/08/Ch3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/1692618879702.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; v&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i : v)<span class="hljs-comment">//使用引用可以改变v中的值， </span><br>    i *= i;<span class="hljs-comment">//计算平方</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : v)<span class="hljs-comment">//普通</span><br>    cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br></code></pre></td></tr></table></figure><blockquote><p>vector使用注意事项：</p><ol type="1"><li>不能使用下标形式添加元素</li><li>不要在范围for中改变vector的大小（比如增加元素等操作）</li></ol></blockquote><h2 id="迭代器">4. 迭代器</h2><p>迭代器可以理解成一种特殊的指针，他有指针类似的操作，除此之外还有自己独特的一些操作。</p><h3 id="使用迭代器">4.1 使用迭代器</h3><p>通常是使用 <code>being</code> 和 <code>end</code>方法获取迭代器，<code>begin</code> 返回第一个元素，<code>end</code>返回最后元素的<strong>下一个位置</strong>，所以<code>end</code>返回的迭代器叫做<strong>尾后迭代器</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> b = v.<span class="hljs-built_in">begin</span>(), e = v.<span class="hljs-built_in">end</span>();<span class="hljs-comment">//b和e类型一样，具体类型后面有说明</span><br></code></pre></td></tr></table></figure><blockquote><p>如果容器为空，则begin和end返回的是同一个迭代器，都是尾后迭代器</p></blockquote><p>迭代器和指针类似，所以指针有的运算符，迭代器基本也有</p><figure><img src="/2023/02/08/Ch3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/1692619629681.png" alt="1692619629681"><figcaption aria-hidden="true">1692619629681</figcaption></figure><blockquote><p>因为 end返回的迭代器并不实际指示某个元素，所以不能对其进行递增或解引用的操作。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">&quot;some string&quot;</span>)</span></span>;<br><span class="hljs-comment">//将第一个单词改为大写形式</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = s.<span class="hljs-built_in">begin</span>(); it != s.<span class="hljs-built_in">end</span>() &amp;&amp; !<span class="hljs-built_in">isspace</span>(*it); ++it)<br>    *it = <span class="hljs-built_in">toupper</span>(*it);<span class="hljs-comment">//将当前字符改成大写形式</span><br></code></pre></td></tr></table></figure><blockquote><p>for循环中使用!=而非&lt;进行判断：所有标准库容器的迭代器都定义了==和!=，而只有string和vector等一些标准库类型有下标运算符。</p></blockquote><p><strong>迭代器类型</strong></p><p>vector 和 string对应的迭代器类型：iterator和const_iterator</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt;::iterator it1;<br>string::iterator ii2;<br><br>vector&lt;<span class="hljs-type">int</span>&gt;::const_iterator it3;<br>string::const_iterator it4;<br></code></pre></td></tr></table></figure><blockquote><p><code>it1</code>, <code>it2</code>是对应类型的迭代器，可以读写。对于常量对象（用const修饰的对象）需要使用<code>const_iterator</code> ,不是常量对象也可使用<code>const_iterator</code> ，只是const迭代器只能读不能修改元素。</p></blockquote><p><strong>begin和end</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; v;<br><span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; cv;<br><span class="hljs-keyword">auto</span> it1 = v.<span class="hljs-built_in">begin</span>();   <span class="hljs-comment">//it1的类型是                              vector&lt;int&gt;::itrerator</span><br><span class="hljs-keyword">auto</span> it2 = cv.<span class="hljs-built_in">begin</span>();  <span class="hljs-comment">//it2的类型是                         vector&lt;int&gt;::const_iterator</span><br><span class="hljs-keyword">auto</span> it3 = v.<span class="hljs-built_in">cbegin</span>();  <span class="hljs-comment">//it3的类型是                       vector&lt;int&gt;::const_iterator</span><br></code></pre></td></tr></table></figure><p><strong>解引用和成员访问</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//it是vector对象的迭代器</span><br>(*it).<span class="hljs-built_in">empty</span>();<span class="hljs-comment">//解引用it,得到vector对象，调用                 vector的empty方法</span><br>*it.<span class="hljs-built_in">empty</span>();<span class="hljs-comment">//错误，这里是访问it中empty的方法，                  而it中并没有这个方法</span><br>it-&gt;<span class="hljs-built_in">empty</span>();<span class="hljs-comment">//使用箭头运算符和                     (*it).empty();一样</span><br></code></pre></td></tr></table></figure><h3 id="迭代器运算">4.2 迭代器运算</h3><p><code>vector</code> 和 <code>string</code> 迭代器支持的运算</p><p><img src="/2023/02/08/Ch3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/1692620516294.png"></p><h2 id="数组">5. 数组</h2><p>数组类似于vector，但是<strong>数组的大小确定不变</strong></p><h3 id="数组的定义和初始化">5.1 数组的定义和初始化</h3><p><strong>维度必须是一个常量表达式</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">unsigned</span> cnt = <span class="hljs-number">42</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">unsigned</span> sz = <span class="hljs-number">42</span>;<br><span class="hljs-type">int</span> arr[<span class="hljs-number">10</span>];<br><span class="hljs-type">int</span> *parr[sz];<span class="hljs-comment">//42个整型指针的数组</span><br>string bad[cnt];<span class="hljs-comment">//错误，cnt不是常量表达式</span><br>string strs[<span class="hljs-built_in">get_size</span>()];  <span class="hljs-comment">//get_size是constexpr时正确；否则错误</span><br></code></pre></td></tr></table></figure><p><strong>显示初始化</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> sz = <span class="hljs-number">3</span>;<br><span class="hljs-type">int</span> ial[sz] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<span class="hljs-comment">// 含有 3 个元素的数组，元   素值分别是 0, 1, 2</span><br><span class="hljs-type">int</span> a2[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;; <span class="hljs-comment">//维度是3的数组</span><br><span class="hljs-type">int</span> a3[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<span class="hljs-comment">// 等价于 a3[] = &#123;0, 1, 2,  0, 0&#125;</span><br>string a4[<span class="hljs-number">3</span>] = &#123;<span class="hljs-string">&quot;hi&quot;</span>, <span class="hljs-string">&quot;byeM&quot;</span>&#125;;<span class="hljs-comment">// 等价于 a4[] = &#123;&quot;hi”，&quot;bye&quot;, &quot;&quot;&#125;</span><br><span class="hljs-type">int</span> a5[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<span class="hljs-comment">// 错误：初始值过多</span><br></code></pre></td></tr></table></figure><h4 id="字符数组的特殊性">字符数组的特殊性</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> a1[] = &#123;<span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;P&#x27;</span>, <span class="hljs-string">&#x27;P&#x27;</span>&#125;;<span class="hljs-comment">//没有空字符</span><br><span class="hljs-type">char</span> a2[] = &#123;<span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;P&#x27;</span>, <span class="hljs-string">&#x27;P&#x27;</span>, <span class="hljs-string">&#x27;\0&#x27;</span>&#125;;<span class="hljs-comment">//手动添加空字符 </span><br><span class="hljs-type">char</span> a3[] = <span class="hljs-string">&quot;CPP&quot;</span>;<span class="hljs-comment">//自动添加空字符</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> a4[<span class="hljs-number">3</span>] = <span class="hljs-string">&quot;CPP&quot;</span>;<span class="hljs-comment">//错误，没有空间存放空字符</span><br></code></pre></td></tr></table></figure><p><strong>不允许拷贝和赋值</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a[] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<br><span class="hljs-type">int</span> a2[] = a;<span class="hljs-comment">//错误，不允许用一个数组初始化另一个数组</span><br>a2 = a; <span class="hljs-comment">//错误，不能把一个数组直接赋值给另一个数组</span><br></code></pre></td></tr></table></figure><h4 id="复杂的数组声明">复杂的数组声明</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> arr[<span class="hljs-number">10</span>];<br><span class="hljs-type">int</span> *ptrs[<span class="hljs-number">10</span>];<span class="hljs-comment">//ptrs是含有10个整型指针的数组</span><br><span class="hljs-type">int</span> &amp;refs[<span class="hljs-number">10</span>] = <span class="hljs-comment">/* ? */</span> ;<span class="hljs-comment">//错误，不存在引用的数组</span><br><span class="hljs-built_in">int</span> (*Parray)[<span class="hljs-number">10</span>] = &amp;arr;<span class="hljs-comment">//Parray是一个指向 int[10] 类型的指针 </span><br><span class="hljs-built_in">int</span> (&amp;arrRef)[<span class="hljs-number">10</span>] = arr;<span class="hljs-comment">//arrRef是一个 int[10]类型的引用</span><br><span class="hljs-type">int</span> *(&amp;arry)[<span class="hljs-number">10</span>] = ptrs;<span class="hljs-comment">//arry是一个引用，指向的是含有10个int*的数组</span><br></code></pre></td></tr></table></figure><blockquote><p>对于上面这些声明，使用<strong>从内至外</strong>的方法读比较合适。</p></blockquote><h4 id="使用数组初始化-vector对象">使用数组初始化 vector对象</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> int_arr[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ivec</span><span class="hljs-params">(begin(int_arr), end(int_arr))</span></span>;<br></code></pre></td></tr></table></figure><h3 id="指针和数组">5.2 指针和数组</h3><p>在c++中，<strong>数组名就是指针，保存的是数组变量的首地址</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> arr[<span class="hljs-number">10</span>];<br><span class="hljs-comment">//p1和p2是等价的</span><br><span class="hljs-type">int</span> *p1 = arr;<br><span class="hljs-type">int</span> *p2 = &amp;arr[<span class="hljs-number">0</span>];<br></code></pre></td></tr></table></figure><blockquote><p>数组就是指针，在把数组作为参数传入函数中，必须手动维护一个数组大小的变量</p><p>因为传入的数组是指针，无法获取到数组的长度</p></blockquote><p><span style="border:2px solid Red">C++11</span> <strong>标准库函数<code>begin</code> 和 <code>end</code></strong></p><p>这两个函数可以获取数组的头元素和尾后元素（最后一个元素的地址）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> ai[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;;<br><span class="hljs-type">int</span> *beg = <span class="hljs-built_in">begin</span>(ia);<span class="hljs-comment">//指向ia首元素的指针</span><br><span class="hljs-type">int</span> *last = <span class="hljs-built_in">end</span>(ia);<span class="hljs-comment">//指向ia尾元素的下一个位置的指针</span><br></code></pre></td></tr></table></figure><p><strong>指针的运算</strong></p><p>指向数组元素的指针可以执行前序所述的迭代器运算。给（从）一个指针加上（减去）某整数值，结果仍是指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>] =&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><span class="hljs-type">int</span> *p = arr;       <span class="hljs-comment">// 等价于int *p = &amp;arr[0]</span><br><span class="hljs-type">int</span> *p2 = p + <span class="hljs-number">4</span>;    <span class="hljs-comment">// p2指向arr的尾元素 arr[4]</span><br><span class="hljs-type">int</span> a = *(arr + <span class="hljs-number">4</span>); <span class="hljs-comment">// 将a初始化成arr[4]的值</span><br></code></pre></td></tr></table></figure><p><strong>下标和指针</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><span class="hljs-type">int</span> *p = &amp;ia[<span class="hljs-number">2</span>];  <span class="hljs-comment">// p指向arr[2]</span><br><span class="hljs-type">int</span> j = p[<span class="hljs-number">1</span>];  <span class="hljs-comment">// p[1]等价于 *(p+1)，即arr[3]</span><br><span class="hljs-type">int</span> k = p[<span class="hljs-number">-2</span>]; <span class="hljs-comment">// 等价于*(p-2)，即arr[0]表示的元素</span><br></code></pre></td></tr></table></figure><h3 id="c风格的字符串">5.3 C风格的字符串</h3><p>在c语言中通常是 <code>const char*</code> 表示字符串，并且以空字符<code>\0</code> 为结尾。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* str = <span class="hljs-string">&quot;heo\0ll&quot;</span>;<span class="hljs-comment">//定义一个c风格的字符串，并且在中间加入一个结束符</span><br><span class="hljs-comment">//因为结束符的原因，c的函数库一些操作会出现意想不到的结果</span><br><span class="hljs-built_in">strlen</span>(str);<span class="hljs-comment">//计算str的长度，结果是3，计算方式是遇到空字符结束</span><br></code></pre></td></tr></table></figure><blockquote><p>c中的字符串是以空字符 <code>\0</code>判断字符串结束，如果我们自己的定义的字符数组或是字符常量中没有<code>\0</code> 或是字符中间有 <code>\0</code> 都不能得到正确的结果</p></blockquote><p><strong>C和C++字符串的转换</strong></p><p>在C++中是定义了一个 <code>string</code> 类作为字符串类型,<code>string</code> 类中重载了系列的运算符，所以从c 风格（<code>const char*</code>） 到c++风格（<code>string</code>）的转换都是自动完成的。以下是一些注意点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//从 c到 c++   const char* ---&gt; string</span><br><span class="hljs-comment">//1. 使用字符串字面v初始化string类型，本章第二节</span><br><span class="hljs-function">string <span class="hljs-title">s3</span><span class="hljs-params">(<span class="hljs-string">&quot;value&quot;</span>)</span></span>;<span class="hljs-comment">//s3是字面值 &quot;value&quot; 的副本，不包含最后的空字符</span><br>string s3 = <span class="hljs-string">&quot;value&quot;</span>;<span class="hljs-comment">//同上</span><br><span class="hljs-comment">//2. string 重载了 + 运算符，可以直接拼接， s1，s2是string类型</span><br>string s4 = s1 + <span class="hljs-string">&quot;, &quot;</span>;<span class="hljs-comment">//正确</span><br>string s5 = <span class="hljs-string">&quot;hello&quot;</span> + <span class="hljs-string">&quot;, &quot;</span>;<span class="hljs-comment">//错误</span><br>string s6 = s1 + <span class="hljs-string">&quot;, &quot;</span> + <span class="hljs-string">&quot;world&quot;</span>;<span class="hljs-comment">//正确</span><br>string s7 = <span class="hljs-string">&quot;hello&quot;</span> + <span class="hljs-string">&quot;, &quot;</span> + s2;<span class="hljs-comment">//错误</span><br><br><span class="hljs-comment">//从 c++到 c,  string ---&gt; const char* </span><br><span class="hljs-comment">//在string类中定义了一个c_str的成员函数，可以返回 const char*</span><br><span class="hljs-type">char</span> *str = s;<span class="hljs-comment">//错误：不能直接使用stringdvx初始化char*</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *str = s.<span class="hljs-built_in">c_str</span>();<span class="hljs-comment">//正确，s是一个string对象，调用c_str()方法</span><br></code></pre></td></tr></table></figure><blockquote><p>说明：在c++的string类种是重载了<code>+</code>,改运算符返回的也是string类型，分析</p><ol type="1"><li>s4, <code>s1</code>是string类型，会调用重载的 <code>+</code></li><li>s5, <code>hello</code> 和 <code>,</code> 都是<code>const char*</code> 类型，该类型并没有定义 <code>+</code> 运算</li><li>s6, <code>(s1 + ", ")</code> 和s4 一样，得到的是一个临时的 string，再 <code>+ "world"</code></li><li>s7, <code>"hello" + ", "</code> 的错误和s5一样</li></ol></blockquote><h2 id="多维数组">6. 多维数组</h2><p><strong>初始化</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> arr[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;&#123;<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">4</span>&#125;,&#123;<span class="hljs-number">8</span>&#125;&#125;;<span class="hljs-comment">//初始化每行的首元素</span><br><span class="hljs-type">int</span> arr2[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;; <span class="hljs-comment">// 初始化第一行</span><br></code></pre></td></tr></table></figure><p><strong>使用范围 for 语句处理多维数组</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> ia[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;row : ia)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> col : row)<br>        cout&lt;&lt;col&lt;&lt;endl;<br></code></pre></td></tr></table></figure><blockquote><p>将外层循环的控制变量声明成了引用类型，是为了<strong>避免数组被自动转成指针</strong>，因为<code>auto row : ia</code>会将row的类型识别为int*，则内层循环不合法。</p><p>要使用范围 for语句处理多维数组，除了最内层的循坏外，其他所有循环的控制变量都应该是引用类型。</p></blockquote><p><strong>指针和多维数组 </strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ;">int arr[3][4];<br>int (*p)[4] = arr; // p指向含有4个int型的数组<br>p = &amp;arr[2];       // p指向arr的尾元素<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++ Primer</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
