<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>第6章 函数</title>
    <link href="/2023/08/25/Ch6-%E5%87%BD%E6%95%B0/"/>
    <url>/2023/08/25/Ch6-%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="第6章-函数">第6章 函数</h1><h2 id="函数的基础">1. 函数的基础</h2><p>一个典型的函数定义包括以下部分：<strong>返回类型</strong>、<strong>函数名</strong>、<strong>形参列表</strong>以及<strong>函数体</strong>。本章的内容也是围绕这几个点展开的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//val的阶乘 val*(val-1)*(val-2)...*1</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fact</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> ret = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (val &gt; <span class="hljs-number">1</span>)<br>        ret *= val--;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-comment">//调用函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> j = <span class="hljs-built_in">fact</span>(<span class="hljs-number">5</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;5! is &quot;</span> &lt;&lt; j &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="局部对象">1.1 局部对象</h3><p>在c++语言中，名字有作用域，对象有生命周期</p><ul><li>名字的作用域是程序文本的一部分，名字在其中可见</li><li>对象的生命周期是程序执行过程中该对象存在的一段时间</li></ul><h4 id="局部变量">局部变量</h4><p>形参和函数内部定义的变量统称<strong>局部变量</strong></p><ul><li>局部变量只在函数内部起作用</li><li>外部全局变量和局部变量同名，局部变量会覆盖全局，这里是名称的覆盖，不是值的覆盖</li></ul><h4 id="局部静态变量">局部静态变量</h4><p>使用<code>static</code>关键字定义静态变量。在程序的执行路径第一次经过变量定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">count_calls</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">size_t</span> ctr = <span class="hljs-number">0</span>; <span class="hljs-comment">// 调用结束后，这个值仍 然有效</span><br>    <span class="hljs-keyword">return</span> ++ctr;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i != <span class="hljs-number">10</span>; ++i)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-built_in">count_calls</span>() &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 输出从1到10（包括10在内）的数字。</span><br></code></pre></td></tr></table></figure><blockquote><p>静态变量存在于程序的整个生命周期，第一次调用<code>count_calls</code>,定义并初始化<code>ctr</code>，之后再调用函数不会再执行初始化，ctr相当于一个全局的变量</p></blockquote><h3 id="函数声明">1.2 函数声明</h3><p>和变量名一样，函数也必须在使用之前声明，<strong>函数可以声明多次，但是只能定义一次</strong>。函数的定义不是必须的，比如声明一个函数，我们从没有调用它，那么它可以不用定义。函数的声明是没有函数体的，<strong>声明可以不写形参名，只声明类型</strong>，但在定义时如果在函数用到形参，则需要写上变量名。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span>;<span class="hljs-comment">//声明可以不写变量名</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span><span class="hljs-comment">//函数体中使用了形参，需要写 变量名</span></span><br><span class="hljs-function">    <span class="hljs-keyword">return</span> a+b</span>;<br></code></pre></td></tr></table></figure><h2 id="参数传递">2. 参数传递</h2><p>形参初始化的机制和变量初始化一样（本节内容可结合第2章的内容看）</p><p>在c++中传参的方式主要有两种：<strong>引用传递</strong>、<strong>值传递</strong></p><h3 id="传值参数">2.1 传值参数</h3><h4 id="普通类型形参">普通类型形参</h4><p>当初始化一个非引用类型的变量时，初始值被拷贝给变量，在函数体内改变的是实参的副本，不会对实参有影响</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//val的阶乘 val*(val-1)*(val-2)...*1</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fact</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> ret = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (val &gt; <span class="hljs-number">1</span>)<br>        ret *= val--;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-comment">//调用函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">5</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;5! is &quot;</span> &lt;&lt; <span class="hljs-built_in">fact</span>(j) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;5! is &quot;</span> &lt;&lt; j &lt;&lt; endl;<span class="hljs-comment">//j的值没有变化</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="指针形参">指针形参</h4><p>指针形参也是值传递的一种方式，传入的指针是实参的副本（一个拷贝出来的指针），同样在函数体中改变指针的值（指向的地址）不会影响实参的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">(<span class="hljs-type">int</span> *p)</span></span><br><span class="hljs-function"></span>&#123;<br>    *ip = <span class="hljs-number">0</span>;<span class="hljs-comment">//改变指针ip所指对象的值</span><br>    ip = <span class="hljs-number">0</span>;<span class="hljs-comment">//改变ip所指向的地址，但是只改变局部变量，实参未被改变</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>值传递的两种方式都是通过拷贝实参进行传值的，如果传入的实参比较大，拷贝会影响程序的性能。</p><p>建议使用下面将要介绍的引用传参的方式</p></blockquote><h3 id="传引用参数">2.2 传引用参数</h3><p>相比于值传递，引用传递是直接将对象传入函数，没有拷贝带来的性能损失，所以在函数体中改变通过引用传入的形参的值，会改变实参</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//这个函数，调用之后会实参的值会变成0</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;i)</span></span><br><span class="hljs-function"></span>&#123;<br>    i = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">42</span>;<br>    <span class="hljs-built_in">reset</span>(j);<br>    cout &lt;&lt; <span class="hljs-string">&quot;j = &quot;</span> &lt;&lt; j &lt;&lt; endl;<span class="hljs-comment">//j的值是0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>建议使用引用传参</strong>，对于不需要改变引用形参的值，可以将其声明为常量引用</p></blockquote><h4 id="引用形参的一种用法">引用形参的一种用法</h4><p>我们知道函数只能返回一个值，然而有时函数需要同时返回多个值，引用形参为我们一次返回多个结果提供了有效的途径。就是我们把需要返回的一个或多个需要返回的值声明为引用形参，在函数体把值写入到引用形参中。</p><h3 id="const形参和实参">2.3 const形参和实参</h3><p>这里涉及到顶层const和底层const的概念。</p><ul><li>用实参初始化形参时会忽略顶层const，也就是说对于一个含有顶层const的形参，可以给它传递常量和非常量对象</li><li>我们可以使用非常量初始化一个底层const对象，但是反过来不行</li></ul><p>将变量的初始化规则应用到参数传递</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//函数原型: int reset(int &amp;i); 和 int reset(int *ip);</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> ci = i;<br>string::size_type ctr = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">reset</span>(&amp;i);<span class="hljs-comment">//调用形参类型为 int* 的 reset</span><br><span class="hljs-built_in">reset</span>(&amp;ci);<span class="hljs-comment">//错误，int *ip = ci;</span><br><span class="hljs-built_in">reset</span>(i);<span class="hljs-comment">//调用形参类型为 int&amp; 的 reset</span><br><span class="hljs-built_in">reset</span>(ci);<span class="hljs-comment">//错误， int *ip = ci;</span><br><span class="hljs-built_in">reset</span>(<span class="hljs-number">42</span>);<span class="hljs-comment">//错误  int &amp;i = 42;</span><br><span class="hljs-built_in">reset</span>(ctr);<span class="hljs-comment">//错误, 类型不匹配</span><br></code></pre></td></tr></table></figure><p><strong>尽量使用常量引用</strong></p><ul><li>当我们把一个不需要改变的形参定义成非常量的话，会给人误导</li><li>定义成常量引用的形参，调用者可以传递常量和非常量实参</li></ul><h3 id="数组形参">2.4 数组形参</h3><ol type="1"><li>不允许拷贝数组，所以<strong>数组不能以值传递的方式传入</strong></li><li>为函数传递一个数组时，实际上传递的是指向数组首元素的指针。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//传入的都是 const int* </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>*)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>[])</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>])</span></span>;<span class="hljs-comment">//这里的维度是希望传入含有10个元素的数组的指针，实际不一定</span><br></code></pre></td></tr></table></figure><blockquote><p>以上三个函数的形参虽然表现形式不一样，但是他们是等价的，都是<code>const int*</code>类型形参</p></blockquote><h4 id="管理指针形参">管理指针形参</h4><p>和其他使用数组的代码一样，以数组作为形参的函数也必须确保使用数组时不越界，下面介绍三种常用的管理指针形参的技术：- 使用标记指定数组长度（如C风格字符串以空字符<code>\0</code>结束） -使用标准库规范（传递数组首元素和尾后元素的指针） -显示的传递一个表示数组大小的形参</p><h4 id="数组引用形参">数组引用形参</h4><p>c++允许将变量定义成数组的引用，同样形参也可以是数组的引用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//形参是数组的引用，维度是类型的一部分</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> (&amp;arr)[<span class="hljs-number">10</span>])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> elem : arr)<br>        cout &lt;&lt; elem &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>上面函数可传入 <code>int arr[10]</code>类型，形参中维度是类型的一部分</p><p><code>&amp;arr</code> 两端的括号不能少，下面两个函数定义不等价</p><p><code>f(int &amp;arr[10])</code>//错误，形参是引用类型的数组，不存在这种类型</p><p><code>f(int (&amp;arr)[])</code>//正确，arr是具有10个整数类型数组的引用</p></blockquote><h4 id="传递多维数组">传递多维数组</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> (*martrix)[<span class="hljs-number">10</span>], <span class="hljs-type">int</span> rowSize)</span> </span>&#123; <span class="hljs-comment">/*...*/</span>&#125;<br></code></pre></td></tr></table></figure><p>上述语句将matrix声明成指向含有10个整数的数组的指针，<code>*matrix</code> 两端的括号不可少</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> *matrix[<span class="hljs-number">10</span>];<span class="hljs-comment">//10个整型指针组成的数组， 这是个数组变量</span><br><span class="hljs-built_in">int</span> (*matrix)[<span class="hljs-number">10</span>];<span class="hljs-comment">//指向含有10个整型的数组的指针， 这是个指针变量</span><br></code></pre></td></tr></table></figure><h3 id="main-命令行选项">2.5 main: 命令行选项</h3><p><code>main</code>函数是可以带参数的，我们在命令输入的命令就是传递到main函数中，假设main函数位于可执行文件<code>prog</code> 之内，我们可以向程序传递下面的选项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">prog -d -o ofile data0</span><br></code></pre></td></tr></table></figure><p>这些命令可以通过两个形参传递给main函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//main函数带形参的两种形式，这两种形式是等价的</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123; ... &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123; ... &#125;<br></code></pre></td></tr></table></figure><p><code>argc</code>表示命令行参数的个数，包括可执行程序本身的文件名，<code>argv</code>存放命令行参数</p><p><code>prog -d -o ofile data0</code> 命令， argc是5， argv内容为：</p><p><code>argv[0] = "prog ";</code></p><p><code>argv[1] = "-d";</code></p><p><code>argv[2] = "-o";</code></p><p><code>argv[3] = "ofile";</code></p><p><code>argv[4] = "data0";</code></p><blockquote><p>当我们需要使用命令行输入的参数时，从<code>argv[1]</code>开始读取，<code>argv[0]</code> 保存的是程序名</p></blockquote><h3 id="含有可变形参的函数">2.6 含有可变形参的函数</h3><h4 id="省略符形参">省略符形参</h4><p>省略符形参是C语言的标准，在C++中也是适用的，它的形式有以下两种</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(parm_list, ...)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(...)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>省略符形参只能出现在形参列表的最后一个位置</strong></p><blockquote><p>第一种形式指定了 <code>foo</code>函数的部分形参的类型，这些形参和正常的形参一样。省略符形参所对应的传入的实参无须类型检查。在第一种形式中，形参声明后的逗号是可选的。</p></blockquote><h4 id="initializer_list-形参">initializer_list 形参</h4><p><span style="border:2px solid Red">C++11</span><code>initializer_list</code>是一种标准库类型，改类型定义在同名的头文件中，它提供的操作如表</p><figure><img src="https://kinvy-images.oss-cn-beijing.aliyuncs.com/Images/image-20211228182857202.png" alt="image-20211228182857202"><figcaption aria-hidden="true">image-20211228182857202</figcaption></figure><p>使用示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">error_msg</span><span class="hljs-params">( initializer_list&lt;string&gt; il)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> beg = il.<span class="hljs-built_in">begin</span>(); beg != il.<span class="hljs-built_in">end</span>(); ++beg)<br>        cout &lt;&lt; *beg &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>initializer_list</code>是一个泛型类，使用时需指定类型，所以传递的多个参数必须是同一种类型</p><p>除了initializer_list 之外，函数也可以有其他的形参</p></blockquote><h2 id="返回类型和return语句">3. 返回类型和return语句</h2><p><code>return</code>语句终止当前正在执行的函数并控制返回到调用该函数的地方。return语句有两种形式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">return</span>;<span class="hljs-comment">//用于无返回值的函数</span><br><span class="hljs-keyword">return</span> expression;<span class="hljs-comment">//用于有返回值的函数</span><br></code></pre></td></tr></table></figure><h3 id="无返回值函数">3.1 无返回值函数</h3><p>没有返回值的 <code>return</code> 语句只能用在返回类型是<code>void</code> 的函数中。返回 void 的函数不要求非得有return语句，这类函数的最后一句后面会隐式地执行return，return可以放在函数内的其他位置，表示提前结束函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;v1, <span class="hljs-type">int</span> &amp;v2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(v1 == v2)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> tmp = v2;<br>    v2 = v1;<br>    v1 = tmp;<br>    <span class="hljs-comment">//此处无须显示的return语句</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>返回值为 <code>void</code> 的函数体中不可以使用<code>return experssion;</code> 返回语句</p></blockquote><h3 id="有返回值函数">3.2 有返回值函数</h3><p>只要函数的返回类型不是 void, 则该函数内的每条 return语句必须返回一个值。return语句返回值的类型必须与函数的返回类型相同，或者能隐式地转换成函数的返回类型。</p><p><strong>不要返回局部对象的引用或是指针</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">const</span> string &amp;<span class="hljs-title">manip</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string ret;<br>    <span class="hljs-keyword">if</span> (!ret.<span class="hljs-built_in">empty</span>())<br>        <span class="hljs-keyword">return</span> ret;<span class="hljs-comment">//错误：返回局部对象的引用！</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Empty&quot;</span>;<span class="hljs-comment">//错误： &quot;Empty&quot;是一个局部临时对象</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>局部对象的指针或是引用，在返回时就会被释放，用变量接收函数的返回值得到的是不存在的对象。</p></blockquote><p><strong>引用返回左值</strong> ----&gt;能为返回类型是非常量引用的函数的结果赋值</p><p><strong>列表初始化返回值</strong> ----&gt;函数可以返回花括号包围的值的列表</p><p><strong>递归</strong> ----&gt;在函数中调用了自身。<strong>递归调用必须要有终止条件</strong></p><h3 id="返回数组指针">3.3 返回数组指针</h3><p>数组不能拷贝，所以函数不能返回数组。不过函数可以返回数组的指针或是引用。直接定义一个返回数组的指针或是引用的函数比较烦琐，先看下使用别名的方式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> arrT[<span class="hljs-number">10</span>];<span class="hljs-comment">//arrT 是一个类型别名，他表示的类型是含有10个整数的数组</span><br><span class="hljs-keyword">using</span> arrT = <span class="hljs-type">int</span>[<span class="hljs-number">10</span>];<span class="hljs-comment">//和上面的等价</span><br><span class="hljs-function">arrT* <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>;<span class="hljs-comment">//使用类型别名定义一个返回10个整数的数组的指针的函数</span><br></code></pre></td></tr></table></figure><h4 id="声明一个返回数组指针的函数">声明一个返回数组指针的函数</h4><p>首先对下面的定义区分一下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> arr[<span class="hljs-number">10</span>];<span class="hljs-comment">//arr是一个含有10个整数的数组</span><br><span class="hljs-type">int</span> *p1[<span class="hljs-number">10</span>];<span class="hljs-comment">//p1是一个含有10个整型指针的数组</span><br><span class="hljs-built_in">int</span> (*p2)[<span class="hljs-number">10</span>] = &amp;arr;<span class="hljs-comment">//p2是一个指针，它指向含有10个整数的数组</span><br></code></pre></td></tr></table></figure><p>返回数组指针的函数的形式如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">Type</span> (*<span class="hljs-built_in">function</span>(parameter_lis)) [dimension]<br></code></pre></td></tr></table></figure><p><code>dimension</code>是指数组的维度，比如和上面使用别名定义的函数的等价形式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">int</span> (*<span class="hljs-built_in">func</span>(<span class="hljs-type">int</span> i)) [<span class="hljs-number">10</span>];<br></code></pre></td></tr></table></figure><p>对于这个函数的定义，我们可以逐层的理解： <code>func(int i)</code>表示一个名为 <code>func</code>，参数为 <code>int i</code> 的函数；<code>*</code> 表示的返回的是指针类型，<code>int* [10]</code>表示是数组类型的指针</p><h4 id="使用尾置返回类型">使用尾置返回类型</h4><p><span style="border:2px solid Red">C++11</span>新标准提供了一种简便的方式定义这样的函数，就是使用<strong>尾置返回类型</strong> ，它的形式是这样的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> -&gt; <span class="hljs-title">int</span><span class="hljs-params">(*)</span>[10]</span>;<br></code></pre></td></tr></table></figure><h4 id="使用-decltype">使用 decltype</h4><p>还有一种情况，如果我们知道函数返回的指针将指向哪个数组，可以使用<code>decltype</code> 关键做声明返回类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> odd[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>&#125;;<br><span class="hljs-type">int</span> even[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>&#125;;<br><span class="hljs-comment">//返回一个指针，该指针指向含有5个整数的数组</span><br><span class="hljs-keyword">decltype</span>(odd) *<span class="hljs-built_in">arrPtr</span>(<span class="hljs-type">int</span> i)  <span class="hljs-comment">//decltype(odd) 后需要加 * 表示对应的指针类型</span><br>&#123;<br>    <span class="hljs-keyword">return</span> (i % <span class="hljs-number">2</span>) ? &amp;odd : &amp;even;<span class="hljs-comment">//返回一个指向数组的指针</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="函数重载">4. 函数重载</h2><p>如果同一作用域内的几个函数名字相同但形参列表不同，我们称之为<strong>重载函数</strong>，下面的几个参数列表不同的函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *cp)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> *beg, <span class="hljs-type">const</span> <span class="hljs-type">int</span> *end)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> ia[], <span class="hljs-type">size_t</span> size)</span></span>;<br><span class="hljs-comment">//函数调用时，编译器会根据传入的参数类型调用不同的函数</span><br><span class="hljs-type">int</span> j[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;;<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello world&quot;</span>); <span class="hljs-comment">//调用 print(const char*)</span><br><span class="hljs-built_in">print</span>(j, <span class="hljs-built_in">end</span>(j) - <span class="hljs-built_in">beging</span>(j));<span class="hljs-comment">//调用第3个</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">begin</span>(j), <span class="hljs-built_in">end</span>(j));<span class="hljs-comment">//调用第2个</span><br></code></pre></td></tr></table></figure><h4 id="定义重载函数">定义重载函数</h4><p>重载函数唯一区分的指标就是形参列表的数量和类型，<strong>只有返回类型不同的函数不是重载函数</strong></p><h4 id="重载和const形参">重载和const形参</h4><p><strong>顶层const是无法区分形参</strong>，所以顶层cosnt形参无法实现重载</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>)</span></span>; <span class="hljs-comment">//和上面声明等价，重复声明</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span>*)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span>* <span class="hljs-type">const</span>)</span></span>; <span class="hljs-comment">//和上面声明等价，重复声明</span><br></code></pre></td></tr></table></figure><p>如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的const是底层const：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp;)</span></span>;<span class="hljs-comment">//函数作用于int的引用</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp;)</span></span>;<span class="hljs-comment">//重载函数，作用于常量引用</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span>*)</span></span>;<span class="hljs-comment">//作用于int类型的指向</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>*)</span></span>;<span class="hljs-comment">//重载函数，作用于指向常量的指针</span><br></code></pre></td></tr></table></figure><blockquote><p>在本章的第2节中讲函数的参数时，有提到形参是常量对象的函数既可以传入常量对象，也可以传入非常量对象，比如上面两组函数中的第二个，它们可以传入常量对象也可传入非常量对象。</p><p>在这里，因为它们都有非常量形参的重载函数，那么在传入非常量对象时编译器会优先选用非常量版本的函数。</p></blockquote><h3 id="重载与作用域">4.1重载与作用域</h3><p><strong>不要在某个语句块（函数体）的内部声明和外部名字一样的变量和函数</strong>。（受到作用域限制，会隐藏外层变量/函数）</p><h2 id="特殊用途语言特性">5. 特殊用途语言特性</h2><h3 id="默认实参">5.1 默认实参</h3><p>有些时候，我们调用函数时，某些形参的值总是被赋予同样的值，只是在少数情况下需要要不同的值。这时我们可以把这样的形参赋予一个默认的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//一个创建窗口的函数，窗口的默认高80，宽180</span><br><span class="hljs-function">string <span class="hljs-title">screen</span><span class="hljs-params">(string name, <span class="hljs-type">int</span> h = <span class="hljs-number">80</span>, <span class="hljs-type">int</span> w = <span class="hljs-number">180</span>)</span></span>;  <br><span class="hljs-built_in">screen</span>(<span class="hljs-string">&quot;window1&quot;</span>);<span class="hljs-comment">//不传入h和w，使用默认值</span><br><span class="hljs-built_in">screen</span>(<span class="hljs-string">&quot;window2&quot;</span>, <span class="hljs-number">100</span>);<span class="hljs-comment">//只传入h, w使用默认值</span><br></code></pre></td></tr></table></figure><blockquote><p>注意：</p><ul><li>默认形参必须定义在形参列表的最后</li><li>实参是按位置解析的，比如需要改变 w 的值，那么h的值也必须传入</li><li>局部变量不能作为默认实参</li></ul></blockquote><h3 id="内联函数和constexpr函数">5.2 内联函数和constexpr函数</h3><h4 id="内联函数">内联函数</h4><p>为了避免函数调用的开销，将一些规模较小、流程直接的函数声明成<strong>内联函数</strong>，内联函数不会有调用的过程，而是直接在调用点把函数体内的语句嵌入进来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">const</span> string &amp;</span><br><span class="hljs-function"><span class="hljs-title">shorterString</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;s1, <span class="hljs-type">const</span> string &amp;s2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> s1.<span class="hljs-built_in">size</span>() &lt;= s2.<span class="hljs-built_in">size</span>() ? s1 : s2;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string s1 = <span class="hljs-string">&quot;hello&quot;</span>;<br>    string s2 = <span class="hljs-string">&quot;world&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-built_in">shorterString</span>(s1, s2) &lt;&lt; endl; <span class="hljs-comment">//等价 cout&lt;&lt; s1.size() &lt;= s2.size() ? s1 : s2 &lt;&lt; endl   </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="constexpr函数">constexpr函数</h3><p>在第2章中有讲到，使用<code>constexpr</code>关键字定义常量表达式，并且可以使用函数的返回值初始化定义的常量。这里使用的函数就是<code>constexpr函数</code>, 语法形式如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">new_sz</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; &#125;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> foo = <span class="hljs-built_in">new_sz</span>();<span class="hljs-comment">//用constexpr函数的返回值初始化一个constexpr变量</span><br></code></pre></td></tr></table></figure><p>constexpr函数在编译阶段就已经计算出了返回值，对于constexpr函数的调用是直接用计算的值替代的。为了编译过程随时展开，constexpr函数被隐式地指定为内联函数。</p><blockquote><p>constexpr函数需遵循：</p><ul><li>函数的返回类型及所有的形参类型都得是字面值类型</li><li>函数体中必须有且只有一条 return 语句</li></ul></blockquote><h3 id="调试帮助">5.3 调试帮助</h3><h4 id="assert预处理宏">assert预处理宏</h4><p><code>assert</code>是一种预处理宏，所谓预处理宏其实是一个预处理变量，它的行为有点类似于内联函数。assert宏使用一个表达作为它的条件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">assert</span>(expr);<br></code></pre></td></tr></table></figure><p>首先对 <code>expr</code>求值，如果表达式为假（即0），assert输出信息并终止程序的执行；如果表达式为真（即非0），assert什么也不做。</p><p>assert宏定义在<code>cassert</code>头文件中，预处理名字由预处理器而非编译器管理，所以我们可以直接使用预处理名字而无需提供using 声明。</p><h4 id="ndebug-预处理变量">NDEBUG 预处理变量</h4><p>assert的行为依赖于一个名为 <code>NDEBUG</code>的预处理变量的状态。如果定义了NDEBUG，则assert什么也不在。默认状态下没有定义NDEBUG。定义NDEBUG既可以在程序中定义，如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NDEBUG</span><br></code></pre></td></tr></table></figure><p>也可以在编译时加上NDEBUG这个参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">CC -D NDEBUG main.c<span class="hljs-comment">#等价于 #define NDEBUG</span></span><br></code></pre></td></tr></table></figure><p>除了assert之外，我们也可以使用NDEBUG编写自己的条件调试代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> ia[], <span class="hljs-type">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> NDEBUG</span><br>    cerr &lt;&lt; __func__ &lt;&lt; <span class="hljs-string">&quot;: array size is &quot;</span> &lt;&lt; size &lt;&lt; endl;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码中 <code>__func__</code> 是编译器定义的变量，它是 const char的一个静态数组，存放当前函数的名字，除了这个，还有其他变量</p><ul><li><code>__FILE__</code> 存放文件名的字符串字面值</li><li><code>__LINE__</code> 存放当前行号的整型字面值</li><li><code>__TIME__</code> 存放文件编译时间的字符串字面值</li><li><code>__DATE__</code> 存放文件编译日期的字符串字面值</li></ul><p>我们可以利用上面这些变量提供错误的详细信息</p><h2 id="函数匹配">6. 函数匹配</h2><p>当重载函数的参数数量一样，只是类型不同的情况下，函数匹配变得有点困难了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> , <span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">double</span>, <span class="hljs-type">double</span> = <span class="hljs-number">3.14</span>)</span></span>;<br><span class="hljs-built_in">f</span>(<span class="hljs-number">5.6</span>);<span class="hljs-comment">//调用 void f(double, double)</span><br></code></pre></td></tr></table></figure><h3 id="实参类型转换">6.1 实参类型转换</h3><p>为了确定最佳匹配，编译器将实参类型到形参类型的转换划分成几个等级，具体如下所示</p><ol type="1"><li>精确匹配，包括以下情况：<ul><li>实参类型和形参类型相同</li><li>实参从数组类型或函数类型转换成对应的指针类型（函数指针下小节会讲）</li><li>向实参添加顶层const或者从实参中删除顶层const</li></ul></li><li>通过const转换实现的匹配</li><li>通过类型提升实现的匹配</li><li>通过算术类型转换实现的匹配</li><li>通过类类型转换实现的匹配</li></ol><h2 id="函数指针">7. 函数指针</h2><p><strong>函数指针</strong>是指针，它指向的是函数。函数的类型由它的返回类型和形参类型共同决定，与函数名无关。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">lengthCompare</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;, <span class="hljs-type">const</span> string &amp;)</span></span>;<br><span class="hljs-comment">//上面函数的类型是</span><br><span class="hljs-built_in">bool</span>(<span class="hljs-type">const</span> string&amp;, <span class="hljs-type">const</span> string&amp;)<br><span class="hljs-comment">//声明一个对应的函数指针</span><br><span class="hljs-built_in">bool</span> (*pf)(<span class="hljs-type">const</span> string&amp;, <span class="hljs-type">const</span> string&amp;);<span class="hljs-comment">//指针pf是函数指针，未初始化</span><br></code></pre></td></tr></table></figure><p>*<strong>pf两端的括号不能少</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//没有括号的话是定义一个名为pf的函数，返回值是 bool*</span><br><span class="hljs-function"><span class="hljs-type">bool</span> *<span class="hljs-title">pf</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp;, <span class="hljs-type">const</span> string&amp;)</span></span>;<br></code></pre></td></tr></table></figure><h4 id="使用函数指针">使用函数指针</h4><p>函数名和数组名一样，直接使用名字（不用取地址符）会自动地转换为指针，例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">pf = lengthCompare;<span class="hljs-comment">//pf 指向名为lengthCompare的函数</span><br>pf = &amp;lengthCompare;<span class="hljs-comment">//和上面的等价，取地址符是可选的</span><br></code></pre></td></tr></table></figure><p>此外，我们还能直接使用指向函数的指针调用该函数，无须提前解引用指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">bool</span> b1 = <span class="hljs-built_in">pf</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;wolrd&quot;</span>);      <span class="hljs-comment">//调用lengthCompare函数</span><br><span class="hljs-type">bool</span> b1 = （*pf）(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;wolrd&quot;</span>);<span class="hljs-comment">//等价的调用</span><br><span class="hljs-type">bool</span> b3 = <span class="hljs-built_in">lengthCompare</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;wolrd&quot;</span>);<span class="hljs-comment">//另一个等价的调用</span><br></code></pre></td></tr></table></figure><p>函数指针也可以赋予 <code>nullptr</code> ,函数指针赋值要和定义的类型一致才可以赋值。</p><h4 id="函数指针形参">函数指针形参</h4><p>和数组类似，虽然不能定义函数类型的形参，但是形参可以是指向函数的指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//第三个参数是函数类型，它会自动转换成函数的指针</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">useBigger</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;s1, <span class="hljs-type">const</span> string &amp;s2, <span class="hljs-type">bool</span> pf(<span class="hljs-type">const</span> string&amp;, <span class="hljs-type">const</span> string&amp;))</span>；</span><br><span class="hljs-function"><span class="hljs-comment">//等价声明</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">useBigger</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;s1, <span class="hljs-type">const</span> string &amp;s2, <span class="hljs-type">bool</span> (*pf)(<span class="hljs-type">const</span> string&amp;, <span class="hljs-type">const</span> string&amp;))</span>；</span><br><span class="hljs-function"><span class="hljs-comment">//函数调用</span></span><br><span class="hljs-function"><span class="hljs-title">useBigger</span><span class="hljs-params">(s1, s2, lengthCompare)</span></span>; <span class="hljs-comment">//函数名自动转换为函数指针</span><br></code></pre></td></tr></table></figure><p>使用别名简化写法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//Func和Func2是函数类型</span><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-type">bool</span> <span class="hljs-title">Func</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp;, <span class="hljs-type">const</span> string&amp;)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">decltype</span><span class="hljs-params">(lengthCompare)</span> Func2</span>;<span class="hljs-comment">//等价类型</span><br><span class="hljs-comment">//FuncP 和FuncP2是指向函数的指针</span><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">bool</span><span class="hljs-params">(*FuncP)</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp;, <span class="hljs-type">const</span> string&amp;)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">decltype</span><span class="hljs-params">(lengthCompare)</span> *FuncP2</span>;<span class="hljs-comment">//等价的类型</span><br><br><span class="hljs-comment">//使用上面的别名声明带函数指针形参的函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">useBigger</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp;, <span class="hljs-type">const</span> string&amp;, Func)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">useBigger</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp;, <span class="hljs-type">const</span> string&amp;, FuncP2)</span></span>;<br></code></pre></td></tr></table></figure><h4 id="返回指向函数的指针">返回指向函数的指针</h4><p>和数组类似，我们不能返回函数，但是可以返回函数指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//定义别名，简化写法</span><br><span class="hljs-keyword">using</span> F = <span class="hljs-built_in">int</span>(<span class="hljs-type">int</span>*, <span class="hljs-type">int</span>);<span class="hljs-comment">//F是函数类型，不是指针</span><br><span class="hljs-keyword">using</span> PF = <span class="hljs-built_in">int</span>(*)(<span class="hljs-type">int</span>*, <span class="hljs-type">int</span>);<span class="hljs-comment">//PF是函数指针类型</span><br><br><span class="hljs-comment">//声明返回函数指针的函数</span><br><span class="hljs-function">PF <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<span class="hljs-comment">//正确， PF是指针函数，f1返回指向函数的指针</span><br><span class="hljs-function">F <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<span class="hljs-comment">//错误，F是函数类型，不能返回函数</span><br><span class="hljs-function">F *<span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<span class="hljs-comment">//正确，显示地指定返回类型是指向函数的指针</span><br><br><span class="hljs-comment">//原始的不使用别名声明方式</span><br><span class="hljs-built_in">int</span> (*<span class="hljs-built_in">f1</span>(<span class="hljs-type">int</span>))(<span class="hljs-type">int</span>*, <span class="hljs-type">int</span>);<br></code></pre></td></tr></table></figure><p>原始的声明是从里向外读， <code>(*f1(int))</code> 表示 <code>f1</code>是一个函数，参数是<code>int</code> ,返回的是指针 <code>*</code> ,指针指向的是函数类型 <code>int(int*, int)</code></p><p>在前面我们声明返回数组指针的函数使用过返回类型后置，同样这里也适用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> -&gt; <span class="hljs-title">int</span><span class="hljs-params">(*)</span><span class="hljs-params">(<span class="hljs-type">int</span>*, <span class="hljs-type">int</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>使用 <code>decltype</code> 自动检测类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string::size_type <span class="hljs-title">sumLength</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp;, <span class="hljs-type">const</span> string&amp;)</span></span>;<br><span class="hljs-keyword">decltype</span>(sumLength) *<span class="hljs-built_in">getFcn</span>(<span class="hljs-type">const</span> string&amp;);<br></code></pre></td></tr></table></figure><blockquote><p>decltype作用于函数时返回的是函数类型而非指针类型，所以需要显示地加上<code>*</code> 声明为指针。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++ Primer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第2章 变量和基本类型</title>
    <link href="/2023/08/21/Ch2-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"/>
    <url>/2023/08/21/Ch2-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="第2章-变量和基本类型">第2章 变量和基本类型</h1><h2 id="基本内置类型">1. 基本内置类型</h2><p>C++ 基本的数据类型有算术类型和空类型，算术类型就是基本的整型和浮点型的数据类型。</p><figure><img src="/2023/08/21/Ch2-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/基本数据类型.png" alt="基本数据类型"><figcaption aria-hidden="true">基本数据类型</figcaption></figure><p>不同类型之间的转换需要注意，有的转换可能是我们不想发生的。</p><p><strong>字面值常量</strong></p><ul><li>数值型，编译器会根据数字形式对应一种基本的数据类型。</li><li>字符和字符串字面常量</li><li>布尔字面值和指针字面值</li></ul><blockquote><p>与其他整型不同, 字符型被分为了三种：char、signed char 和 unsignedchar，但表现形式只有带符号和无符号两种。<strong>char实际上会表现为signed char和unsignedchar中的一种，由编译器决定。</strong></p></blockquote><h2 id="变量">2. 变量</h2><p>变量提供一个具名的、可供程序操作的存储空间。</p><p>###　2.1 变量定义</p><p>C++变量的定义要指定变量的类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//变量定义并初始化</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">2</span>;<br><span class="hljs-comment">//变量定义</span><br><span class="hljs-type">int</span> b;<br><span class="hljs-comment">//变量赋值</span><br>b = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><blockquote><p>在C++中变量的初始化和赋值是有区别的， <code>int a = 2;</code>的<code>=</code> 运算符表示的是初始化，</p><p>而在 <code>b=1;</code> 中的 <code>=</code> 是赋值。</p></blockquote><p><span style="border:2px solid Red">C++11</span> 初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> val = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> val = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> val&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">val</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>使用 <code>&#123;&#125;</code>来初始化变量，称为<strong>列表初始化</strong>，如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">long</span> <span class="hljs-type">double</span> pi = <span class="hljs-number">3.14</span>;<br><span class="hljs-type">int</span> a&#123;pi&#125;;<span class="hljs-comment">//错误，存在丢失信息的风险，无法通过编译</span><br></code></pre></td></tr></table></figure><blockquote><p>总结：C++变量初始化的语法形式有三种：<code>=</code> , <code>()</code>, <code>&#123;&#125;</code></p></blockquote><p><strong>默认初始化</strong>，定义变量时没有初始化变量的值，则变量会被默认初始化。默认初始化的值取决于变量定义的类型。==定义在函数体内的局部变量和类中的成员属性是不会被初始化的==所以不用试图使用任何方式去访问这些变量。</p><h3 id="声明和定义">2.2 声明和定义</h3><p><strong>声明</strong>，使程序知道变量（对象）的存在</p><p><strong>定义</strong>，负责创建与名字关联的实体 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> i;<span class="hljs-comment">//声明i而不定义</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<span class="hljs-comment">//extern失效,变成定义</span><br><span class="hljs-type">int</span> j;<span class="hljs-comment">//声明并定义j</span><br></code></pre></td></tr></table></figure><blockquote><p>变量能且只能被定义一次，但是可以被多次声明</p></blockquote><h3 id="标识符作用域">2.3-4 标识符、作用域</h3><h4 id="标识符">标识符</h4><p>变量命名按照规范，不要使用保留关键字。</p><p>==命名规则，供参考：==</p><ul><li>普通的局部变量和函数参数名使用小驼峰（第一个单词首字母小写，其他单词首字母大写），例： <code>userName</code></li><li>全局变量前加 <code>g_</code>, 后面的按小驼峰规则 ，<code>g_userName</code></li><li>静态变量前加 <code>s_</code> , 后面按小驼峰规则，<code>s_userName</code></li><li>类名使用大驼峰，所有单词的首字母大写 , <code>UserManage</code></li><li>类属性（成员变量）前面加 <code>m_</code> ,后面按小驼峰规则 ，<code>m_userName</code></li><li>常量全部使用大写，多个单词用<code>_</code> 分割，<code>MAX_NUMBER</code></li></ul><h4 id="作用域">作用域</h4><p>局部变量不宜和全局的变量重名，嵌套的块，内部的不要和外部的重名。</p><h2 id="复合类型">3. 复合类型</h2><p>一条声明语句由一个 <strong>基本数据类型</strong> 和紧随其后的一个<strong>声明符</strong> 列表组成。</p><h3 id="引用">3.1 引用</h3><p><strong>引用</strong> 就是为变量（对象）起一个别名</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> val = <span class="hljs-number">1024</span>;<br><span class="hljs-type">int</span> val1 = <span class="hljs-number">102</span>;<br><span class="hljs-type">int</span>&amp; refVal = val;<span class="hljs-comment">//refVal指向val</span><br>refVal = val1;<span class="hljs-comment">//refVal引用并没有改变，只是改变了refVal指向的变量val的值，val = val1</span><br><span class="hljs-type">int</span> &amp;refVal2;<span class="hljs-comment">//错误，引用必须初始化</span><br></code></pre></td></tr></table></figure><blockquote><p>注意:</p><ol type="1"><li>引用只能绑定在对象上，而不能与字面值或表达式计算结果绑定</li><li>引用必须初始化，且不能改变</li><li><code>&amp;</code> 符号可以紧靠基本类型(int), 也可以紧靠变量名</li><li>因为引用本身不是一个对象，所以不能定义引用的引用</li></ol></blockquote><p><strong>以上说的引用都是左值引用，C++11还有右值引用</strong></p><h3 id="指针">3.2 指针</h3><p><strong>指针</strong>就是一个整数，没有实际的数值大小，只是一个编号，这个编号指向的是内存中的某个地址。</p><p>指针 vs 引用：</p><ul><li>指针本身是一个对象没允许对指针赋值和拷贝</li><li>在指针的生命周期内它可以先后指向几个不同的对象</li><li>指针无需在定义时赋值<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="但建议定义时初始化，如果没有想好指向哪个变量，可以初始化为空指针。">[1]</span></a></sup></li></ul><p>指针的定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> *p1, *p2;<span class="hljs-comment">//p1, p2都是指针类型， 定义在一条语句中，每个变量都要加 *</span><br></code></pre></td></tr></table></figure><blockquote><p>指针无论定义成什么基本类型，其值都是一个固定位数的整数，指针类型数据的大小取决于系统的位数</p><p>32bit的系统指针是4byte = 32 bit, 64 bit系统指针式 8 byte = 64bit</p></blockquote><p>指定类型的指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> val = <span class="hljs-number">102</span>;<br><span class="hljs-type">int</span> *p = &amp;val;<span class="hljs-comment">//指针p指向val变量的内存地址</span><br></code></pre></td></tr></table></figure><blockquote><p>定义指定类型的指针只是为了提供操作数据时需要操作的字节数。</p><p>例如，<code>int</code>型的指针，在使用指针改变指向的数据时，改变的是以该指针变量为首地址的4个字节内存，</p><p>同样对<code>int</code>型指针的加或减的操作也是以4个字节为基本单位</p></blockquote><p><code>*</code>(解引用符) 和 <code>&amp;</code>(取地址符)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> val = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> *p = <span class="hljs-literal">nullptr</span>;  <span class="hljs-comment">//* 表示定义一个指针变量，并且初始化为空指针，等价于 int *p = 0</span><br>p = &amp;val;<span class="hljs-comment">//&amp; 表示取val变量的地址值</span><br>std::cout &lt;&lt; *p &lt;&lt; std::endl;<span class="hljs-comment">//* 表示解引用，取出p地址指向的值，即 val</span><br></code></pre></td></tr></table></figure><p>赋值和指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> val = <span class="hljs-number">42</span>;<br><span class="hljs-type">int</span> *p = <span class="hljs-number">0</span>;<br>p = &amp;val; <span class="hljs-comment">//p的值被改变，现在p指向了val</span><br>*p = <span class="hljs-number">0</span>;   <span class="hljs-comment">//val的值被改变，指针p并没有改变</span><br></code></pre></td></tr></table></figure><blockquote><p>指针使用建议：</p><ol type="1"><li>指针定义是可以不初始化，但建议定义时初始化，如果没有想好指向哪个变量，可以初始化为空指针</li><li>操作指针时，须确定操作的不是空指针和野指针（无效指针）</li></ol></blockquote><h3 id="理解复合类型的声明">3.3 理解复合类型的声明</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i = <span class="hljs-number">42</span>;<br><span class="hljs-type">int</span> *p;<span class="hljs-comment">//p是int型的指针</span><br><span class="hljs-type">int</span> *&amp;r = p;<span class="hljs-comment">//r是一个对int型指针p的引用</span><br><br>r = &amp;i;<span class="hljs-comment">//r是一个指针引用，因此给r赋值&amp;i就是令p指向i</span><br>*r = <span class="hljs-number">0</span>;<span class="hljs-comment">//解引用r,就是解引用指针p,将p指向的变量i的值改为0</span><br></code></pre></td></tr></table></figure><blockquote><p>Tip:面对一条比较复杂的指针或引用的声明语句时，<strong>从右向左</strong>读有助于弄清楚它的真实含义。</p><p>离变量名最近的符号（此例中是&amp;r的符号&amp;）对变量的类型有最直接的影响，因此 r 是一个引用。声明符的其余部分用以确定 r 引用的类型是什么，此例中的符号*说明r 引用的是一个指针。最后，声明的基本数据类型部分指出 r 引用的是一个 int指针 。</p></blockquote><h2 id="const-限定符">4. const 限定符</h2><p>const 用于定义一个不能改变的变量, 所以定义时就必须初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">cont <span class="hljs-type">int</span> bufSize = <span class="hljs-number">512</span>;<span class="hljs-comment">//用字面值常量初始化</span><br>cont <span class="hljs-type">int</span> i = <span class="hljs-built_in">get_size</span>();<span class="hljs-comment">//用函数返回值初始化， 运行时初始化</span><br><span class="hljs-type">int</span> j = <span class="hljs-number">10</span>;<br>cont <span class="hljs-type">int</span> k = j;<span class="hljs-comment">//用其他变量初始化</span><br></code></pre></td></tr></table></figure><blockquote><p><code>const</code> 定义的变量只对本文件可见，要使其他文件也可见需使用<code>extern</code></p></blockquote><h3 id="const的引用">4.1 const的引用</h3><ul><li><p><strong>对常量的引用不能被用作修改它所绑定的对象</strong></p></li><li><p><strong>允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式</strong>==此时常量引用实际上绑定了一个临时量对象==</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i = <span class="hljs-number">42</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> j = <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;r1 = i;<span class="hljs-comment">//正确，允许将 const int&amp;绑定到一个普通int对象</span><br>r1 = <span class="hljs-number">10</span>;<span class="hljs-comment">//错误，不能通过常量引用改变i的值</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;r2 = <span class="hljs-number">42</span>;<span class="hljs-comment">//正确</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;r3 = r1 * <span class="hljs-number">2</span>;<span class="hljs-comment">//正确</span><br><span class="hljs-type">int</span>&amp; r4 = j;<span class="hljs-comment">//错误</span><br><span class="hljs-type">int</span> &amp;r4 = r1 * <span class="hljs-number">2</span>;<span class="hljs-comment">//错误</span><br></code></pre></td></tr></table></figure><p>==组合关系==</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;"><code>int i</code></th><th style="text-align: center;"><code>cont int i</code></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>int &amp;r</code></td><td style="text-align: center;">✔</td><td style="text-align: center;">❌</td></tr><tr class="even"><td style="text-align: center;"><code>cont int &amp;r</code></td><td style="text-align: center;">✔</td><td style="text-align: center;">✔</td></tr></tbody></table><h3 id="指针和const">4.2 指针和const</h3><p>指向常量的指针和对常量的引用类似：</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;"><code>int i</code></th><th style="text-align: center;"><code>cont int i</code></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>int *p</code></td><td style="text-align: center;">✔</td><td style="text-align: center;">❌</td></tr><tr class="even"><td style="text-align: center;"><code>cont int *p</code></td><td style="text-align: center;">✔</td><td style="text-align: center;">✔</td></tr></tbody></table><blockquote><p>Tip:所谓指向常量的指针或引用，不过是指针或引用“自以为是”罢了，它们觉得自己指向了常量，所以自觉地不去改变所指对象的值。</p></blockquote><h4 id="常量指针">常量指针</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> errNumb = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> *<span class="hljs-type">const</span> curErr = &amp;errNumb;<span class="hljs-comment">//curErr将一直指向errNumb,不可以改变指向</span><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> pi = <span class="hljs-number">3.14</span>;<br>cont <span class="hljs-type">double</span> *<span class="hljs-type">const</span> pip = &amp;pi;<span class="hljs-comment">//pip是一个指向常量对象的常量指针</span><br>*curErr = <span class="hljs-number">1</span>;  <span class="hljs-comment">//正确，把curErr所指的对象的值设为1</span><br>*pip = <span class="hljs-number">2.72</span>;  <span class="hljs-comment">//错误，pip是一个指向常量的指针</span><br></code></pre></td></tr></table></figure><p>==<strong>从右向左读</strong>==</p><blockquote><p>C++ Primer 5th :</p><p><a id="const point">常量指针</a>：该变量是一个指针，指针本身是一个常量，即它的指向初始化后不可以改变</p></blockquote><h3 id="顶层const">4. 3 顶层const</h3><p><strong>顶层const</strong> :表示该变量（对象）本身是常量，不可以改变</p><p><strong>底层const</strong>: 表示指向的变量（对象）是一个常量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> *<span class="hljs-type">const</span> p1 = &amp;i;<span class="hljs-comment">//p1是指针，p1的指向不能改变，顶层</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> ci = <span class="hljs-number">42</span>;<span class="hljs-comment">//ci是普通变量，ci的值不能改变，顶层</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *p2 = &amp;ci;<span class="hljs-comment">//p2是一个指针，它必须指向 const int型的数据，但是本身的指向可以改变，底层</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *<span class="hljs-type">const</span> p3 = p2;<span class="hljs-comment">//第一个底层，第二个顶层</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;r = ci;<span class="hljs-comment">//用于声明引用的const都是底层</span><br></code></pre></td></tr></table></figure><p>==引用类型的变量自带顶层const==即引用一旦赋值（指向某个变量）就不可以再变化（指向另一个变量）</p><h3 id="constexpr和常量表达式">4.4 constexpr和常量表达式</h3><p>指值不会改变并且在编译过程就能得到计算结果的表达式。</p><p><strong>constexpr和指针</strong></p><blockquote><p>一个constexpr指针的初始值必须是nullptr或者0,或者是存储于某个固定地址中的对象</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> *p1 = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> *p2 = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-type">int</span> *<span class="hljs-type">const</span> p3 = <span class="hljs-literal">nullptr</span>;<br></code></pre></td></tr></table></figure><blockquote><p>p2和p3是等价的，<code>constexpr</code>修饰指针变量是被定义为顶层const</p></blockquote><h2 id="处理类型">5. 处理类型</h2><p>为了复杂程序更加易读易写，通常会给类型取别名，或是利用C++提供的特性自动推导复杂类型。</p><h3 id="类型别名">5.1 类型别名</h3><h4 id="typedef">typedef</h4><p>传统的方法是使用 <code>typedef</code> 关键字定义类型别名</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">double</span> wages;<span class="hljs-comment">//wages表示是double类型</span><br><span class="hljs-keyword">typedef</span> wages base, *p;<span class="hljs-comment">//base = wages = double, p = double*</span><br><span class="hljs-comment">//数组的别名</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> arrT[<span class="hljs-number">10</span>];<span class="hljs-comment">//arrT是一个类型别名，他表示的类型是含有10个整数的数组</span><br><span class="hljs-keyword">using</span> arrT = <span class="hljs-type">int</span>[<span class="hljs-number">10</span>];<span class="hljs-comment">//和上面的等价</span><br></code></pre></td></tr></table></figure><h4 id="using">using</h4><p><span style="border:2px solid Red">C++11</span>提供了一种新的方式，使用 <code>using</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> SI = Sales_item;<span class="hljs-comment">//Sales_item是一个类类型， SI表示是该类的别名</span><br></code></pre></td></tr></table></figure><blockquote><p>这里的 <code>using</code> 要和 <code>using namespace std;</code> 中的<code>using</code>区分开。后者是表示引入命名空间，类似于java和python的导包操作</p></blockquote><h4 id="指针常量和类型别名">指针、常量和类型别名</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span>* pstring;<br><span class="hljs-type">const</span> pstring cstr = <span class="hljs-number">0</span>;<span class="hljs-comment">//char *const cstr = 0;</span><br><span class="hljs-type">const</span> pstring *ps;<span class="hljs-comment">//char **const ps;</span><br></code></pre></td></tr></table></figure><p><strong>第二行的定义不能理解成 <code>const char *cstr = 0;</code></strong></p><blockquote><p><code>const pstring</code> 中 <code>const</code> 是对<code>pstring</code> 的修饰，而 <code>pstring</code> 是一个<code>char*</code> 类型，因此 <code>const pstring</code> 是指向 char的<a href="#const%20point">常量指针</a> ，而并不是指向常量字符的指针</p></blockquote><h3 id="auto-类型说明符">5.2 auto 类型说明符</h3><p><span style="border:2px solid Red">C++11</span> <code>auto</code>类型说明符可以让编译器分析表达式所属的类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> val1 = <span class="hljs-number">1</span>, val2 = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">auto</span> val = val1 + val2;<span class="hljs-comment">//编译器可以自动推出val为int类型</span><br><span class="hljs-keyword">auto</span> i = <span class="hljs-number">0</span>, *p = &amp;i;<span class="hljs-comment">//正确，编译器通过字面值推出i为int,p为int*</span><br><span class="hljs-keyword">auto</span> sz = <span class="hljs-number">0</span>; pi = <span class="hljs-number">3.14</span>;<span class="hljs-comment">//错误，编译器无法推出类型， sz， pi类型不一致无法统一</span><br></code></pre></td></tr></table></figure><h4 id="复合类型常量和auto">复合类型、常量和auto</h4><ul><li><p>当使用引用类型推导类型时，<code>auto</code>推导的类型是引用指向变量的实际类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; &amp;r = i;<br><span class="hljs-keyword">auto</span> a = r;<span class="hljs-comment">// r是int型的引用,因此a是int型</span><br></code></pre></td></tr></table></figure></li><li><p><code>auto</code>会忽略掉顶层const, 同时底层const则会保留下来</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> ci = i, &amp;cr = ci;<br><span class="hljs-keyword">auto</span> b = ci;<span class="hljs-comment">//int b = ci;</span><br><span class="hljs-keyword">auto</span> c = cr;<span class="hljs-comment">//int c = cr;  cr是ci的别名，ci本身是一个顶层const</span><br><span class="hljs-keyword">auto</span> d = &amp;i;<span class="hljs-comment">//int *d = &amp;i;</span><br><span class="hljs-keyword">auto</span> e = &amp;ci;<span class="hljs-comment">//const int *e = &amp;ci; 对常量对象取地址是一种底层const</span><br></code></pre></td></tr></table></figure><p>如果希望推断出的auto类型是一个顶层const，需要明确指出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> f = ci;<span class="hljs-comment">// const int f = ci;</span><br></code></pre></td></tr></table></figure><p>指定引用类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> &amp;g = ci;<span class="hljs-comment">//const int &amp;g = ci;</span><br><span class="hljs-keyword">auto</span> &amp;h = <span class="hljs-number">42</span>;<span class="hljs-comment">//错误，int &amp;h = 42;</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;j = <span class="hljs-number">42</span>; <span class="hljs-comment">//const int &amp;j = 42;</span><br></code></pre></td></tr></table></figure></li></ul><blockquote><p>auto 使用建议：</p><p>使用auto声明变量一定要做到心里有数，你知道编译器会推断出的什么样的类型</p><p>通常使用auto是对于一些类型名比较复杂的变量，使用auto写起来更方便</p></blockquote><h3 id="decltype-类型指示符">5.3 decltype 类型指示符</h3><p><span style="border:2px solid Red">C++11</span> <code>decltype</code>可以不执行表达式，编译器自动推断出表达式的返回值类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">f</span>()) sum = x;<span class="hljs-comment">//sum的类型和f()的返回类型一样</span><br></code></pre></td></tr></table></figure><p>通过 <code>f()</code> 推断出返回类型，但是并不会执行<code>f()</code></p><h4 id="decltype-和const">decltype 和const</h4><p><code>decltype</code>处理顶层 consth和引用的方式和auto有点不同，如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（==包括顶层const和引用在内==）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> ci = <span class="hljs-number">0</span>, &amp;cj = ci;<br><span class="hljs-keyword">decltype</span>(ci) x = <span class="hljs-number">0</span>;<span class="hljs-comment">//const int x = 0</span><br><span class="hljs-keyword">decltype</span>(cj) y = <span class="hljs-number">0</span>;<span class="hljs-comment">//const int &amp;y = 0;</span><br><span class="hljs-keyword">decltype</span>(cj) z;<span class="hljs-comment">//错误， const int &amp;z;  引用必须初始化</span><br></code></pre></td></tr></table></figure><h4 id="decltype-和引用">decltype 和引用</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> i = <span class="hljs-number">42</span>, *p = &amp;i, &amp;r = i;<br><span class="hljs-keyword">decltype</span>(r + <span class="hljs-number">0</span>) b;<span class="hljs-comment">//int b;</span><br><span class="hljs-keyword">decltype</span>(*p) c;<span class="hljs-comment">//错误， int &amp;c; 引用需要初始化</span><br></code></pre></td></tr></table></figure><blockquote><p><code>r</code> 是引用 <code>decltype(r)</code> 是引用，但是<code>r + 0</code> 是一个int型数据</p><p>解引用指针得到的是指针所指的对象，，因此 <code>decltype(*p)</code> 是<code>int&amp;</code></p></blockquote><p>变量加上 <code>()</code> 得到的是引用类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">decltype</span>((i)) d;   <span class="hljs-comment">//错误， int&amp; d; 引用类型需要初始化</span><br><span class="hljs-keyword">decltype</span>(i) e;<span class="hljs-comment">// int e;</span><br></code></pre></td></tr></table></figure><p>==<code>decltype((variable))</code> 的结果永远是引用==</p><h2 id="自定义数据结构">6. 自定义数据结构</h2><p>这里的自定义数据结构就是指类类型的数据，在C++中定义类的关键字有<code>class</code>和 <code>struct</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassName</span>&#123;<br><span class="hljs-comment">//属性</span><br><span class="hljs-comment">//方法</span><br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ClassName</span>&#123;<br><span class="hljs-comment">//属性</span><br><span class="hljs-comment">//方法</span><br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p><code>class</code> 和 <code>struct</code>在功能上是完全一样的，两者唯一的不同是默认的权限不同</p><p><code>class</code>默认的权限是私有的(private), 而 <code>struct</code>是公有的(public)</p></blockquote><p><em>注意：c语言中的结构体是不能有方法（函数）</em></p><p>关于类更具体的介绍在后面的章节~~</p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>但建议定义时初始化，如果没有想好指向哪个变量，可以初始化为空指针。<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++ Primer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CCLF(基于内容连接度和位置感知的自适应转发)</title>
    <link href="/2023/04/15/20230415-CCLF/"/>
    <url>/2023/04/15/20230415-CCLF/</url>
    
    <content type="html"><![CDATA[<h2 id="information">Information:</h2><ol type="1"><li>Title: Leveraging Content Connectivity and Location Awareness forAdaptive Forwarding in NDN-based Mobile Ad Hoc Networks(基于内容连接性和位置感知的NDN移动自组织网络自适应转发技术)</li><li>Authors: Muktadir Chowdhury, Junaid Ahmed Khan, and Lan Wang</li><li>Affiliation: University of Memphis (孟菲斯大学)</li><li>Keywords: Named Data Networking, MANET, routing, forwarding(命名数据网络，移动自组织网络，路由，转发)</li><li>Urls: Paper link: https://dl.acm.org/doi/10.1145/3405656.3418713,Github: None.</li></ol><h2 id="summary">Summary:</h2><ul><li>(1):本文研究了移动自组织网络（MANETs）中的数据转发问题，提出了基于命名数据网络（NDN）的内容连接性和位置感知的自适应转发策略。</li><li>(2):传统的MANET转发策略在高度动态的网络中很难有效转发数据，并且在存在连接变化时通常需要大量控制报文来获取拓扑信息。本文提出的方法是<strong>基于内容连接性和位置信息</strong>对数据进行转发，避免了控制报文的开销，并且通过在网络层维护转发状态和期望转发反馈来加强转发策略的适应性。</li><li>(3): 文中提出了一个自适应转发策略——Content Connectivity andLocation-Aware Forwarding(CCLF)，在NDN网络中进行转发时基于内容连接性和位置信息，避免了控制报文和数据报文之间的不一致，并且通过减少无效广播来提升转发性能。此外还提出了适用于MANET网络的链路自适应层（A-LAL）以增强链路的灵活性和可靠性。</li><li>(4):研究结果表明，CCLF能够有效降低数据转发的负载并保证数据的可靠获取，在信息中心化车联网方案中也比其他转发策略表现更为优异，验证了其在移动自组织网络中的有效性。</li></ul><h2 id="method">Method:</h2><p>CCLF广播NDN数据包，让每个节点根据每个前缀的内容连接度和任何可用的地理位置信息独立地决定是否转发数据包；此外，它采用密度感知的抑制机制来减少不必要的包传输；此外，为adhoc链路开发了链路适配层，以弥合CCLF与底层链路能力之间的差距。</p><h3 id="内容连接度">内容连接度</h3><p>内容连接度是<strong>细粒度</strong>的，区分于以往基于节点的整体兴趣满意度来量化节点的连通性，CCLF对<strong>每一个名称前缀</strong>分别计算一个内容连通性分数(ContentConnectivity Score, CCS)。</p><blockquote><p>This fine-grained measure of forwarding performance helps the networklayer make more informed decisions when forwarding Interests to retrievedata from different producers.</p></blockquote><p>CCS计算公式： <span class="math display">\[CCS_j = \frac{D_j+\sum_{i\in Desc(j)}D_i}{I_j+\sum_{i\in Desc(j)}I_i}\]</span> <span class="math inline">\(D_j,I_j\)</span>分别表示对应前缀<span class="math inline">\(j\)</span>的Data、Interest个数，<span class="math inline">\(Desc(j)\)</span>表示前缀<span class="math inline">\(j\)</span>的子类的集合。</p><p>CCS周期性更新，根据指数加权移动平均(EWMA): <span class="math display">\[\widehat{CCS}_{i,N}=\alpha \cdot CCS_{i,N}+(1-\alpha) \cdot\widehat{CCS}_{i,N-1}\]</span></p><h3 id="地理位置">地理位置</h3><p>地理位置在CCLF中作为<strong>可选项</strong>使用，Consumer可以将数据的位置附加到Interest中（<em>通过NDNLP header</em>）,节点接收到此类Interest后，计算位置分数（LocationScore,LS）: <span class="math display">\[LS = 1- \frac{Dist(n,d)}{max(Dist(n,d),Dist(p,d))}\]</span> <span class="math inline">\(p,n,d\)</span>分别代表上一跳、当前、目的节点。</p><p>CCS和位置信息通过新设定的C-L tree结构来储存、更新与检索： <img src="/2023/04/15/20230415-CCLF/1681475432881.png" alt="C-L tree"></p><h3 id="转发计时器">转发计时器</h3><p>和其他策略类似，当某个节点通过其广播链路发送Interest后，传输范围内的其他节点分布式决定<strong>是否以及何时</strong>转发该兴趣。首先对CCS和LS加权： <span class="math display">\[w = \beta \cdot \widehat{CCS} + (1-\beta) \cdot LS\]</span> 再取倒数计算基本的定时器时间t: <span class="math display">\[t= \begin{cases}\min \left(\frac{1}{w}, T\right), &amp; \text { if }w&gt;0 \\ T, &amp; \text { if } w=0\end{cases}\]</span> T为t的一个上界，最终定时器的值在<span class="math inline">\(0.5t-1.5t\)</span>之间随机选取。</p><h3 id="密度感知的转发抑制">密度感知的转发抑制</h3><p>当节点在某个Interest的转发计时器到期之前收到相同Interest时，它使用一个<strong>与其邻居数量成正比的抑制概率</strong>来决定是否取消自己的兴趣转发：<span class="math display">\[p=min(K \cdot n, 1)\]</span><em>Data包也采用相同的概率抑制方案，不过在Data包转发中，节点的Timer值是相同的。</em></p><h3 id="ad-hoc链路适配层">AD-HOC链路适配层</h3><p>开发了新的一个Ad-hoc Link AdaptationLayer(A-LAL)层面，为CCLF提供一些重要操作：</p><figure><img src="/2023/04/15/20230415-CCLF/1681479229022.png" alt="A-LAL"><figcaption aria-hidden="true">A-LAL</figcaption></figure><ul><li>在Interes包中添加NDNLP头(previous hop location和data location)</li><li>利用MAC层的信息来跟踪邻居节点的数量(Neighbor-List)，以支持转发抑制概率的计算</li><li>没有邻居节点时，存储包(PacketQueue)直至发现邻居</li></ul><p>最后，总的转发流程伪代码如下： <img src="/2023/04/15/20230415-CCLF/1681480197163.png" alt="Interest转发"></p><figure><img src="/2023/04/15/20230415-CCLF/1681480213422.png" alt="Data包转发"><figcaption aria-hidden="true">Data包转发</figcaption></figure><h2 id="conclusion">Conclusion:</h2><ul><li>(1):本文提出了一种基于内容连接性和位置感知的自适应转发策略，CCLF，用于解决移动自组织网络（MANETs）中的数据转发问题，具有实际应用价值。</li><li>(2):创新点：本文提出的CCLF算法在转发决策中加入了内容连接性和位置信息，可以有效地避免控制报文开销和数据报文不一致问题，并减少无效广播，具有较高的性能表现。但是本文研究还存在一定的局限性，需要进一步拓展研究范围，对算法的参数调整及不同情境的适用性进行更深入的研究，并进行更全面的评估测试。</li><li>性能：CCLF相较于传统的转发策略，在满足数据转发的负载要求的同时减少了数据转发的开销，具有较高的性能表现。</li><li>工作量：本文的研究范围相对狭窄，需要进一步的实验和评估工作以证明其普适性和适用性。</li></ul>]]></content>
    
    
    <categories>
      
      <category>论文阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NDN</tag>
      
      <tag>Ad hoc</tag>
      
      <tag>转发</tag>
      
      <tag>地理位置</tag>
      
      <tag>可靠性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ad Hoc</title>
    <link href="/2023/03/31/20230323/"/>
    <url>/2023/03/31/20230323/</url>
    
    <content type="html"><![CDATA[<h2 id="汪浩东周报">20230323汪浩东周报</h2><p>本周主要对于AdHoc中的相关问题进行了更深的思考，以期找到其（包括无线场景）的问题，尤其是在与NDN相结合的方面，因为经过小组讨论认为，目前我们仍未搞清楚将大背景移到无线场景下时，会有什么不同以及新的问题的来源及解决方案。</p><h3 id="ad-hoc无线场景下的问题以广播风暴为例">AdHoc(无线)场景下的问题（以广播风暴为例）</h3><p>首先是这个大的背景问题，对于无线以及AdHoc这个新场景，其所面临的问题我们始终没有理清楚，以广播风暴为例。</p><p>首先，在无线AdHoc网络中，因为没有有线连接的支持，以及无线信道的有损性（在Adhoc中还需要考虑移动性），因此一般采用广播的方式传输包，注意，此处的广播指的是数据链路层，即使用共享广播信道，让所有主机接收同样的包。而这样的广播方式将会带来以下三个问题：#### 冗余对于冗余这个概念，之前我的理解是：“多个主机对相同的包都进行了广播，从而导致了冗余”，但实际上这个理解是错误的，其真正含义应该为：&gt;<strong><em>“当主机决定将收到的广播消息再次广播给邻居时，它的邻居实际上已经拥有了该消息”</em></strong></p><p>即它的邻居实际上已经收到了来自于其他主机的相同广播消息，再次广播是不必要的，因此称其为<strong><em>“冗余”</em></strong>。具体以下图来说明：<img src="/2023/03/31/20230323/OneDrive%20-%20USTC\mySVN\Whd\Md\assets\广播冗余.png" alt="广播冗余">如图所示，B在A的通信范围内，当B收到A的广播消息后，如果其决定再次广播，则能受益的区域（即没有被A广播到的区域）面积为：<span class="math display">\[\text{EAC}=|S_{B-A}| = |S_A|-|S_{A \cap B}| = \pi r^2 - \text{INTC}(d)= \pi r^2 - 4 \int_{d/2}^{r} \sqrt{r^2-x^2}\]</span> 当<span class="math inline">\(d=r\)</span>时，上式取得最大值，但也仅为<span class="math inline">\(0.61\pir^2\)</span>，考虑一般情况，假设B随机处于A的通信范围内任意位置，则可求得EAC的均值为：</p><p><span class="math display">\[ \int_0^r \frac{2\pi x \cdot [\pi r^2 -\text{INTC}(x)]}{\pi r^2} dx \approx 0.41\pi r^2\]</span></p><p>再次将场景扩展，考虑在一个主机的通信范围内存在多个主机的情况下，则相应的再次广播能够带来的额外覆盖率EAC比例与主机数<span class="math inline">\(k\)</span>的关系如下图所示： <img src="/2023/03/31/20230323/OneDrive%20-%20USTC\mySVN\Whd\Md\assets\1679580193476.png" alt="1679580193476"></p><p>由图可见，当<span class="math inline">\(k\)</span>超过4之后，再次广播所带来的额外覆盖增益已经低于<span class="math inline">\(0.05\%\)</span>，即此时再次广播明显是冗余的。[^Note][^Note]:对于并不处于通信范围内的多个主机，当其收到相同广播消息并且向同一节点进行再次广播操作时，这是有必要的，因为可以提升下一节点收到消息的概率，这便体现出了原来的理解的错误之处。</p><h4 id="争用">争用</h4><p>争用实际上应当是广播风暴在Adhoc中最为致命的一点。如前所述，在广播操作中，多个主机实际上是共享相同的广播信道，因此当多个主机同时想要进行广播操作时，就会产生争用问题。</p><p>以两个主机为例，假设B和C都接收到了A的广播消息，则只有当C处于<span class="math inline">\(S_{A\cap B}\)</span>区域时，会发生争用，其概率为：<span class="math display">\[\int_0^r \frac{2 \pi x \cdot text{INTC}(x)/\pi r^2}{\pi r^2}dx \approx 59\%\]</span>当此场景扩展到A的通信范围内有<span class="math inline">\(n\)</span>个主机，则有<span class="math inline">\(k\)</span>个主机在重播时没有发生争用的概率如图所示：<img src="/2023/03/31/20230323/OneDrive%20-%20USTC\mySVN\Whd\Md\assets\1679582024824.png" alt="1679582024824"> 由图可见，当<span class="math inline">\(n \geq6\)</span>时，所有主机都经历争用的概率<span class="math inline">\(cf(n,0)\)</span>已经超过0.8。</p><h4 id="冲突">冲突</h4><p>首先，是CSMA/CA协议，区别于有限局域网中的CSMA/CD协议，在无线环境中，采用的是CA(collisionavoidance)，而非CD(collisiondetection)。无论CSMA/CA还是CSMA/CD，其思想都来源于CSMA(Carrier SenseMultiple Access)，而CSMA实际上来源于Aloha，Aloha的思想可以概括如下：</p><blockquote><p>一个aloha节点只要有数据的话，该节点就可以立即发送。当该节点数据发送完之后，其需要等待接收方反馈的ACK。若成功接收到ACK之后，那么这一次传输成功。如果没有收到ACK的话，那么这一次传输失败。该aloha节点会认为网络中还存在另外一个aloha节点也在发送数据，所以造成接收方发生了冲突。最后这些冲突的节点会随机选择一个时间进行退避（backoff），以避免下一次冲突。若冲突节点回退完成，其才可以重新进行发送。</p></blockquote><p>而CSMA相对与Aloha，增添了LBT(listen before talk)机制，即：</p><blockquote><p>CSMA节点在每一次发送之前先监听信道是否是空闲的，如果信道不是空闲的话，那么就不发送数据，等待一会再进行尝试。只有确保是空闲的情况下，才可以发送数据，从而避免打断其他节点正在进行的传输过程。</p></blockquote><p>其可以分为三种模式<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Difference between 1-persistent, p-persistent and Non-persistent CSMA - GeeksforGeeks](https://www.geeksforgeeks.org/difference-between-1-persistent-p-persistent-and-non-persistent-csma/)">[1]</span></a></sup>：</p><ul><li>1-persistentesCSMA：“<strong>节点需要持续监听信道，一旦节点发现信道空闲后，则立刻发送数据。</strong>”</li><li>0-persistentesCSMA：“<strong>节点不连续监听信道，若该时刻节点监听信道为busy，那么等待一段时间后，再次进行监听。若节点该时刻监听信道为空闲，则立刻发送数据。</strong>”</li><li>p-persistentesCSMA：“<strong>节点需要持续监听信道，一旦发现信道空闲后，节点以p的概率立刻发送数据，以1-p的概率不发送数据。若节点该时刻不发送数据，那么等待一段时间后，再次进行监听，并以p概率再次发送</strong>”。</li></ul><p>在以上三种CSMA机制中，若节点传输发送冲突，则类似aloha的基本算法，随机等待一个时间之后，再次进行重试。接下来便可以进一步探讨CSMA/CD与CSMA/CA。</p><p>在思想上，CSMA/CD类似于1-persistentesCSMA，而CSMA/CA类似于p-persistentesCSMA，即CSMA/CD是持续监听信道，一旦监听到空闲立刻发生数据，在发送数据时依然检测信道是否有冲突，如果有冲突就停止发送并等待一段随机时间后重试；CSMA/CA是在发送数据前检测信道是否空闲，如果空闲则对backoffcounter进行减一操作，直至counter为零才可以发送数据并等待确认帧，如果不空闲则挂起counter，等待一段随机时间后重试。两者的对比可参见<a href="https://www.geeksforgeeks.org/difference-between-csma-ca-and-csma-cd/?ref=rp">Differencebetween CSMA/CA and CSMA/CD - GeeksforGeeks</a>、<a href="https://www.geeksforgeeks.org/carrier-sense-multiple-access-csma/">CarrierSense Multiple Access (CSMA) - GeeksforGeeks</a></p><p>知道了两者的不同之后，产生了一个新问题：为什么在无线环境下不再执行CD，而是需要更改为CA？</p><p>在有线网络中，如果发生冲突，站点可以通过接收信号的能量变化来检测到冲突。因此，它们可以立即停止发送并等待一段随机时间后再重试，这样可以减少冲突的可能性和浪费的带宽。而在无线网络中，由于信号能量的变化很小，站点很难检测到冲突。因此，它们需要等待整个数据包发送完毕后才能知道是否发生了冲突。这样会导致更多的带宽浪费和延迟。所以，在无线网络中，冲突避免更加重要和必要。</p><h4 id="隐藏终端和暴露终端">隐藏终端和暴露终端</h4><p>在无线环境下，还有两个很重要的问题，即隐藏终端和暴露终端，如下面两张图所示。<img src="/2023/03/31/20230323/OneDrive%20-%20USTC\mySVN\Whd\Md\assets\隐蔽站和暴露站.png"></p><p>对于隐藏终端问题，可以通过RTS/CTS机制来解决：在发送数据之前，站点先发送一个请求发送（RTS）的信号给接收站点，接收站点回复一个清除发送（CTS）的信号给发送站点和其他邻近站点。这样，其他邻近站点就知道有一个正在进行的传输，并且等待一段时间后再尝试发送，这种方式可以有效地减少隐藏终端问题造成的冲突和带宽浪费。</p><p>但需要注意的是，RTS/CTS机制在IEEE802.11协议中是可选项而非必选项，因为如果 A正在向 B发送一个小数据包，那么对于A来说，简单地发送数据包并准备好在它受到干扰时重新发送，比试图阻止这种干扰要便宜得多。</p><p><strong>以上所讨论的都是一对一的情况，实际上在802.11中不考虑一对多的情况</strong></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.geeksforgeeks.org/difference-between-1-persistent-p-persistent-and-non-persistent-csma/">Differencebetween 1-persistent, p-persistent and Non-persistent CSMA -GeeksforGeeks</a><a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>第3章 字符串、向量和数组</title>
    <link href="/2023/02/08/Ch3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/"/>
    <url>/2023/02/08/Ch3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="第3章-字符串向量和数组">第3章 字符串、向量和数组</h1><h2 id="命名空间的using声明">1. 命名空间的using声明</h2><p>在前面的示例程序中，输入和输出都是写成 <code>std::cin</code> ,<code>std::cout</code> , 我们可以在使用前使用 <code>using</code>声明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> std::cin;<br><span class="hljs-keyword">using</span> std::cout; <span class="hljs-keyword">using</span> std::endl;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> v1, v2;<br>    cin &gt;&gt; v1 &gt;&gt; v2;<br>    cout&lt;&lt;<span class="hljs-string">&quot;Ths sum is&quot;</span>&lt;&lt; v1 + v2 &lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>一行可放多条using声明语句，但每个名字都需要独立的using声明。</strong></p><blockquote><p>实际更常见的做法是使用 <code>using namespace std;</code>把整个命名空间都引入，这样std命名空间下的成员都可以使用了。</p><p>注意：头文件中尽量不要引入整个命名空间，因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件里有某个using 声明，那么每个使用了该头文件的文件就都会有这个声明，这样可能会和自己写的一些类名冲突。</p></blockquote><h2 id="标准库类型-string">2. 标准库类型 string</h2><p><code>string</code>表示可变长的字符序列，<code>string</code>的使用需要包含一个头文件和命名空间</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br></code></pre></td></tr></table></figure><h3 id="定义和初始化string对象">2.1 定义和初始化string对象</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">string s1;<span class="hljs-comment">//默认初始化， s1是一个空串</span><br><span class="hljs-function">string <span class="hljs-title">s2</span><span class="hljs-params">(s1)</span></span>;<span class="hljs-comment">//s2是s1的副本</span><br>string s2 = s1;    <span class="hljs-comment">//等价于s2(s1),s2是s1的副本</span><br><span class="hljs-function">string <span class="hljs-title">s3</span><span class="hljs-params">(<span class="hljs-string">&quot;value&quot;</span>)</span></span>; <span class="hljs-comment">//直接初始化，s3是字面值&quot;value&quot;                       的副本，不包含最后的空字符</span><br>string s3 = <span class="hljs-string">&quot;value&quot;</span>; <span class="hljs-comment">//拷贝初始化，s3是字面                                值“vale&quot; 的副本</span><br><span class="hljs-function">string <span class="hljs-title">s4</span><span class="hljs-params">(n, <span class="hljs-string">&#x27;c&#x27;</span>)</span></span>;<span class="hljs-comment">//连续n个&#x27;c&#x27;组成的串</span><br></code></pre></td></tr></table></figure><h3 id="string对象上的操作">2.2 string对象上的操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">os &lt;&lt; s;<span class="hljs-comment">//将s写到输出流os中，返回os</span><br>is &gt;&gt; s;<span class="hljs-comment">//从is中读取字符串赋给s,字符串以                       空白分隔，返回is</span><br><span class="hljs-built_in">getline</span>(is, s);<span class="hljs-comment">//从is中读取一行赋给s,返回is</span><br>s.<span class="hljs-built_in">empty</span>();<span class="hljs-comment">//s为空返回true，否则返回false</span><br>s.<span class="hljs-built_in">size</span>();<span class="hljs-comment">//返回s中字符的个数</span><br>s[n];<span class="hljs-comment">//返回s中第n个字符的引用，位置从0                       开始</span><br>s1 + s2;<span class="hljs-comment">//返回s1和s2连接后的结果</span><br>s1 = s2;<span class="hljs-comment">//用s2的副本代替s1中原来的字符</span><br>s1 == s2;<span class="hljs-comment">//判断是否一致</span><br>s1 != s2;<span class="hljs-comment">//判断是否不一样</span><br>&lt; , &lt;=, &gt;, &gt;=<span class="hljs-comment">//通过字典中的顺序比较，对字母大小                       写敏感</span><br></code></pre></td></tr></table></figure><blockquote><p>size()函数返回的类型是string::size_type</p></blockquote><p>字面值和string对象相加</p><p><strong>当把 <code>string</code>对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保每个加法运算符(+) 的两侧的运算对象至少有一个是<code>string</code></strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">string s1 = <span class="hljs-string">&quot;hello&quot;</span>;<br>string s4 = s1 + <span class="hljs-string">&quot;, &quot;</span>;       <span class="hljs-comment">//正确</span><br>string s5 = <span class="hljs-string">&quot;hello&quot;</span> + <span class="hljs-string">&quot;, &quot;</span>;  <span class="hljs-comment">//错误</span><br>string s6 = s1 + <span class="hljs-string">&quot;, &quot;</span> + <span class="hljs-string">&quot;world&quot;</span>; <span class="hljs-comment">//正确</span><br>string s7 = <span class="hljs-string">&quot;hello&quot;</span> + <span class="hljs-string">&quot;, &quot;</span> + s2;  <span class="hljs-comment">//错误</span><br></code></pre></td></tr></table></figure><blockquote><p>字符串字面值与string是不同的类型</p></blockquote><h3 id="处理string对象中的字符">2.3 处理string对象中的字符</h3><p>在头文件 <code>cctype</code> 中定义了一组相关的函数</p><p><img src="https://kinvy-images.oss-cn-beijing.aliyuncs.com/Images/image-20211216191219702.png"></p><blockquote><p><code>cctype</code>是c语言的头文件，在c++中包含c的头文件有两种形式</p><ul><li><code>#include &lt;ctype.h&gt;</code> 和c语言一样</li><li><code>#include &lt;cctype&gt;</code> 不加 <code>.h</code>而是在前面加一个 <code>c</code></li></ul></blockquote><p><strong>基于范围的for语句</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//语法</span><br><span class="hljs-keyword">for</span> (declaration : expression)<br>    statement<br>    <br><span class="hljs-comment">//示例</span><br>string str = <span class="hljs-string">&quot;helloWorld&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> s : str)  <span class="hljs-comment">//使用aotu自动类型推导</span><br>&#123;<br>    cout &lt;&lt; s &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//如果需要改变str中字符，用引用</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;c : str)<br>&#123;<br>    c = <span class="hljs-built_in">toupper</span>(c);<span class="hljs-comment">//c是引用</span><br>&#125;<br>cout &lt;&lt; str &lt;&lt; endl;<br></code></pre></td></tr></table></figure><blockquote><p>基于范围的for，只适用于可迭代的对象</p></blockquote><h2 id="标准库类型-vector">3. 标准库类型 vector</h2><p>标准库类型 vector表示对象的集合，其中所有对象的类型都相同。用vector需要包含下面的头文件和声明命名空间</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> std::vector;<span class="hljs-comment">//或者 using namespace std; 引入std命名空间所有的成员</span><br></code></pre></td></tr></table></figure><p><code>vector</code>类似于数组，但是比数组用于更多的操作。<code>vector</code>是一个模板类，所谓模板就是该类内部中的属性没有指定某种特定的数据类型，我们可以在声明vector时指定数据类型（包括基本类型和自定义类型）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; ivec;<span class="hljs-comment">//ivec时int类型的对象集合</span><br>vector&lt;Sales_item&gt; Sales_vec;<span class="hljs-comment">//Sales_vec是Sales_item类型的对象集合</span><br>vector&lt;vector&lt;string&gt;&gt; file;<span class="hljs-comment">//该向量的元素是vector对象</span><br></code></pre></td></tr></table></figure><h3 id="定义和初始化vector对象">3.1 定义和初始化vector对象</h3><p>定义vector对象的常用方法</p><p><img src="/2023/02/08/Ch3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/1692618512009.png"></p><blockquote><p>注意 <code>()</code> 和 <code>&#123;&#125;</code> 初始化vector对象的区别。</p><p><code>()</code>是用来构造vector对象；<code>&#123;&#125;</code>是列表初始化该对象</p></blockquote><p><strong>如果初始化时使用了花括号的形式但是提供的值又不能用来列表初始化，就要考虑用这样的值来构造vector对象了</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;string&gt; v5&#123;<span class="hljs-string">&quot;hi&quot;</span>&#125;; <span class="hljs-comment">//列表初始化：v5有一个元素</span><br><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">v6</span><span class="hljs-params">(<span class="hljs-string">&quot;hi&quot;</span>)</span></span>; <span class="hljs-comment">//错误：不能使用字符串字面值构建vector对象</span><br>vector&lt;string&gt; v7&#123;<span class="hljs-number">10</span>&#125;;  <span class="hljs-comment">//v7有10个默认初始化的元素</span><br>vector&lt;string&gt; v8&#123;<span class="hljs-number">10</span>,<span class="hljs-string">&quot;hi&quot;</span>&#125;; <span class="hljs-comment">//v8有10个值为&quot;hi&quot;的元素</span><br></code></pre></td></tr></table></figure><h3 id="vector操作">3.2 vector操作</h3><p>vector常用的操作</p><p><img src="/2023/02/08/Ch3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/1692618879702.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; v&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i : v)<span class="hljs-comment">//使用引用可以改变v中的值， </span><br>    i *= i;<span class="hljs-comment">//计算平方</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : v)<span class="hljs-comment">//普通</span><br>    cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br></code></pre></td></tr></table></figure><blockquote><p>vector使用注意事项：</p><ol type="1"><li>不能使用下标形式添加元素</li><li>不要在范围for中改变vector的大小（比如增加元素等操作）</li></ol></blockquote><h2 id="迭代器">4. 迭代器</h2><p>迭代器可以理解成一种特殊的指针，他有指针类似的操作，除此之外还有自己独特的一些操作。</p><h3 id="使用迭代器">4.1 使用迭代器</h3><p>通常是使用 <code>being</code> 和 <code>end</code>方法获取迭代器，<code>begin</code> 返回第一个元素，<code>end</code>返回最后元素的<strong>下一个位置</strong>，所以<code>end</code>返回的迭代器叫做<strong>尾后迭代器</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> b = v.<span class="hljs-built_in">begin</span>(), e = v.<span class="hljs-built_in">end</span>();<span class="hljs-comment">//b和e类型一样，具体类型后面有说明</span><br></code></pre></td></tr></table></figure><blockquote><p>如果容器为空，则begin和end返回的是同一个迭代器，都是尾后迭代器</p></blockquote><p>迭代器和指针类似，所以指针有的运算符，迭代器基本也有</p><p><img src="/2023/02/08/Ch3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/1692619629681.png"></p><blockquote><p>因为 end返回的迭代器并不实际指示某个元素，所以不能对其进行递增或解引用的操作。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">&quot;some string&quot;</span>)</span></span>;<br><span class="hljs-comment">//将第一个单词改为大写形式</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = s.<span class="hljs-built_in">begin</span>(); it != s.<span class="hljs-built_in">end</span>() &amp;&amp; !<span class="hljs-built_in">isspace</span>(*it); ++it)<br>    *it = <span class="hljs-built_in">toupper</span>(*it);<span class="hljs-comment">//将当前字符改成大写形式</span><br></code></pre></td></tr></table></figure><blockquote><p>for循环中使用!=而非&lt;进行判断：所有标准库容器的迭代器都定义了==和!=，而只有string和vector等一些标准库类型有下标运算符。</p></blockquote><p><strong>迭代器类型</strong></p><p>vector 和 string对应的迭代器类型：iterator和const_iterator</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt;::iterator it1;<br>string::iterator ii2;<br><br>vector&lt;<span class="hljs-type">int</span>&gt;::const_iterator it3;<br>string::const_iterator it4;<br></code></pre></td></tr></table></figure><blockquote><p><code>it1</code>, <code>it2</code>是对应类型的迭代器，可以读写。对于常量对象（用const修饰的对象）需要使用<code>const_iterator</code> ,不是常量对象也可使用<code>const_iterator</code> ，只是const迭代器只能读不能修改元素。</p></blockquote><p><strong>begin和end</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; v;<br><span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; cv;<br><span class="hljs-keyword">auto</span> it1 = v.<span class="hljs-built_in">begin</span>();   <span class="hljs-comment">//it1的类型是                              vector&lt;int&gt;::itrerator</span><br><span class="hljs-keyword">auto</span> it2 = cv.<span class="hljs-built_in">begin</span>();  <span class="hljs-comment">//it2的类型是                         vector&lt;int&gt;::const_iterator</span><br><span class="hljs-keyword">auto</span> it3 = v.<span class="hljs-built_in">cbegin</span>();  <span class="hljs-comment">//it3的类型是                       vector&lt;int&gt;::const_iterator</span><br></code></pre></td></tr></table></figure><p><strong>解引用和成员访问</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//it是vector对象的迭代器</span><br>(*it).<span class="hljs-built_in">empty</span>();<span class="hljs-comment">//解引用it,得到vector对象，调用                 vector的empty方法</span><br>*it.<span class="hljs-built_in">empty</span>();<span class="hljs-comment">//错误，这里是访问it中empty的方法，                  而it中并没有这个方法</span><br>it-&gt;<span class="hljs-built_in">empty</span>();<span class="hljs-comment">//使用箭头运算符和                     (*it).empty();一样</span><br></code></pre></td></tr></table></figure><h3 id="迭代器运算">4.2 迭代器运算</h3><p><code>vector</code> 和 <code>string</code> 迭代器支持的运算</p><p><img src="/2023/02/08/Ch3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/1692620516294.png"></p><h2 id="数组">5. 数组</h2><p>数组类似于vector，但是<strong>数组的大小确定不变</strong></p><h3 id="数组的定义和初始化">5.1 数组的定义和初始化</h3><p><strong>维度必须是一个常量表达式</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">unsigned</span> cnt = <span class="hljs-number">42</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">unsigned</span> sz = <span class="hljs-number">42</span>;<br><span class="hljs-type">int</span> arr[<span class="hljs-number">10</span>];<br><span class="hljs-type">int</span> *parr[sz];<span class="hljs-comment">//42个整型指针的数组</span><br>string bad[cnt];<span class="hljs-comment">//错误，cnt不是常量表达式</span><br>string strs[<span class="hljs-built_in">get_size</span>()];  <span class="hljs-comment">//get_size是constexpr时正确；否则错误</span><br></code></pre></td></tr></table></figure><p><strong>显示初始化</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> sz = <span class="hljs-number">3</span>;<br><span class="hljs-type">int</span> ial[sz] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<span class="hljs-comment">// 含有 3 个元素的数组，元   素值分别是 0, 1, 2</span><br><span class="hljs-type">int</span> a2[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;; <span class="hljs-comment">//维度是3的数组</span><br><span class="hljs-type">int</span> a3[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<span class="hljs-comment">// 等价于 a3[] = &#123;0, 1, 2,  0, 0&#125;</span><br>string a4[<span class="hljs-number">3</span>] = &#123;<span class="hljs-string">&quot;hi&quot;</span>, <span class="hljs-string">&quot;byeM&quot;</span>&#125;;<span class="hljs-comment">// 等价于 a4[] = &#123;&quot;hi”，&quot;bye&quot;, &quot;&quot;&#125;</span><br><span class="hljs-type">int</span> a5[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<span class="hljs-comment">// 错误：初始值过多</span><br></code></pre></td></tr></table></figure><h4 id="字符数组的特殊性">字符数组的特殊性</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> a1[] = &#123;<span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;P&#x27;</span>, <span class="hljs-string">&#x27;P&#x27;</span>&#125;;<span class="hljs-comment">//没有空字符</span><br><span class="hljs-type">char</span> a2[] = &#123;<span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;P&#x27;</span>, <span class="hljs-string">&#x27;P&#x27;</span>, <span class="hljs-string">&#x27;\0&#x27;</span>&#125;;<span class="hljs-comment">//手动添加空字符 </span><br><span class="hljs-type">char</span> a3[] = <span class="hljs-string">&quot;CPP&quot;</span>;<span class="hljs-comment">//自动添加空字符</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> a4[<span class="hljs-number">3</span>] = <span class="hljs-string">&quot;CPP&quot;</span>;<span class="hljs-comment">//错误，没有空间存放空字符</span><br></code></pre></td></tr></table></figure><p><strong>不允许拷贝和赋值</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a[] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<br><span class="hljs-type">int</span> a2[] = a;<span class="hljs-comment">//错误，不允许用一个数组初始化另一个数组</span><br>a2 = a; <span class="hljs-comment">//错误，不能把一个数组直接赋值给另一个数组</span><br></code></pre></td></tr></table></figure><h4 id="复杂的数组声明">复杂的数组声明</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> arr[<span class="hljs-number">10</span>];<br><span class="hljs-type">int</span> *ptrs[<span class="hljs-number">10</span>];<span class="hljs-comment">//ptrs是含有10个整型指针的数组</span><br><span class="hljs-type">int</span> &amp;refs[<span class="hljs-number">10</span>] = <span class="hljs-comment">/* ? */</span> ;<span class="hljs-comment">//错误，不存在引用的数组</span><br><span class="hljs-built_in">int</span> (*Parray)[<span class="hljs-number">10</span>] = &amp;arr;<span class="hljs-comment">//Parray是一个指向 int[10] 类型的指针 </span><br><span class="hljs-built_in">int</span> (&amp;arrRef)[<span class="hljs-number">10</span>] = arr;<span class="hljs-comment">//arrRef是一个 int[10]类型的引用</span><br><span class="hljs-type">int</span> *(&amp;arry)[<span class="hljs-number">10</span>] = ptrs;<span class="hljs-comment">//arry是一个引用，指向的是含有10个int*的数组</span><br></code></pre></td></tr></table></figure><blockquote><p>对于上面这些声明，使用<strong>从内至外</strong>的方法读比较合适。</p></blockquote><h4 id="使用数组初始化-vector对象">使用数组初始化 vector对象</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> int_arr[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ivec</span><span class="hljs-params">(begin(int_arr), end(int_arr))</span></span>;<br></code></pre></td></tr></table></figure><h3 id="指针和数组">5.2 指针和数组</h3><p>在c++中，<strong>数组名就是指针，保存的是数组变量的首地址</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> arr[<span class="hljs-number">10</span>];<br><span class="hljs-comment">//p1和p2是等价的</span><br><span class="hljs-type">int</span> *p1 = arr;<br><span class="hljs-type">int</span> *p2 = &amp;arr[<span class="hljs-number">0</span>];<br></code></pre></td></tr></table></figure><blockquote><p>数组就是指针，在把数组作为参数传入函数中，必须手动维护一个数组大小的变量</p><p>因为传入的数组是指针，无法获取到数组的长度</p></blockquote><p><span style="border:2px solid Red">C++11</span> <strong>标准库函数<code>begin</code> 和 <code>end</code></strong></p><p>这两个函数可以获取数组的头元素和尾后元素（最后一个元素的地址）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> ai[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;;<br><span class="hljs-type">int</span> *beg = <span class="hljs-built_in">begin</span>(ia);<span class="hljs-comment">//指向ia首元素的指针</span><br><span class="hljs-type">int</span> *last = <span class="hljs-built_in">end</span>(ia);<span class="hljs-comment">//指向ia尾元素的下一个位置的指针</span><br></code></pre></td></tr></table></figure><p><strong>指针的运算</strong></p><p>指向数组元素的指针可以执行前序所述的迭代器运算。给（从）一个指针加上（减去）某整数值，结果仍是指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>] =&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><span class="hljs-type">int</span> *p = arr;       <span class="hljs-comment">// 等价于int *p = &amp;arr[0]</span><br><span class="hljs-type">int</span> *p2 = p + <span class="hljs-number">4</span>;    <span class="hljs-comment">// p2指向arr的尾元素 arr[4]</span><br><span class="hljs-type">int</span> a = *(arr + <span class="hljs-number">4</span>); <span class="hljs-comment">// 将a初始化成arr[4]的值</span><br></code></pre></td></tr></table></figure><p><strong>下标和指针</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><span class="hljs-type">int</span> *p = &amp;ia[<span class="hljs-number">2</span>];  <span class="hljs-comment">// p指向arr[2]</span><br><span class="hljs-type">int</span> j = p[<span class="hljs-number">1</span>];  <span class="hljs-comment">// p[1]等价于 *(p+1)，即arr[3]</span><br><span class="hljs-type">int</span> k = p[<span class="hljs-number">-2</span>]; <span class="hljs-comment">// 等价于*(p-2)，即arr[0]表示的元素</span><br></code></pre></td></tr></table></figure><h3 id="c风格的字符串">5.3 C风格的字符串</h3><p>在c语言中通常是 <code>const char*</code> 表示字符串，并且以空字符<code>\0</code> 为结尾。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* str = <span class="hljs-string">&quot;heo\0ll&quot;</span>;<span class="hljs-comment">//定义一个c风格的字符串，并且在中间加入一个结束符</span><br><span class="hljs-comment">//因为结束符的原因，c的函数库一些操作会出现意想不到的结果</span><br><span class="hljs-built_in">strlen</span>(str);<span class="hljs-comment">//计算str的长度，结果是3，计算方式是遇到空字符结束</span><br></code></pre></td></tr></table></figure><blockquote><p>c中的字符串是以空字符 <code>\0</code>判断字符串结束，如果我们自己的定义的字符数组或是字符常量中没有<code>\0</code> 或是字符中间有 <code>\0</code> 都不能得到正确的结果</p></blockquote><p><strong>C和C++字符串的转换</strong></p><p>在C++中是定义了一个 <code>string</code> 类作为字符串类型,<code>string</code> 类中重载了系列的运算符，所以从c 风格（<code>const char*</code>） 到c++风格（<code>string</code>）的转换都是自动完成的。以下是一些注意点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//从 c到 c++   const char* ---&gt; string</span><br><span class="hljs-comment">//1. 使用字符串字面v初始化string类型，本章第二节</span><br><span class="hljs-function">string <span class="hljs-title">s3</span><span class="hljs-params">(<span class="hljs-string">&quot;value&quot;</span>)</span></span>;<span class="hljs-comment">//s3是字面值 &quot;value&quot; 的副本，不包含最后的空字符</span><br>string s3 = <span class="hljs-string">&quot;value&quot;</span>;<span class="hljs-comment">//同上</span><br><span class="hljs-comment">//2. string 重载了 + 运算符，可以直接拼接， s1，s2是string类型</span><br>string s4 = s1 + <span class="hljs-string">&quot;, &quot;</span>;<span class="hljs-comment">//正确</span><br>string s5 = <span class="hljs-string">&quot;hello&quot;</span> + <span class="hljs-string">&quot;, &quot;</span>;<span class="hljs-comment">//错误</span><br>string s6 = s1 + <span class="hljs-string">&quot;, &quot;</span> + <span class="hljs-string">&quot;world&quot;</span>;<span class="hljs-comment">//正确</span><br>string s7 = <span class="hljs-string">&quot;hello&quot;</span> + <span class="hljs-string">&quot;, &quot;</span> + s2;<span class="hljs-comment">//错误</span><br><br><span class="hljs-comment">//从 c++到 c,  string ---&gt; const char* </span><br><span class="hljs-comment">//在string类中定义了一个c_str的成员函数，可以返回 const char*</span><br><span class="hljs-type">char</span> *str = s;<span class="hljs-comment">//错误：不能直接使用stringdvx初始化char*</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *str = s.<span class="hljs-built_in">c_str</span>();<span class="hljs-comment">//正确，s是一个string对象，调用c_str()方法</span><br></code></pre></td></tr></table></figure><blockquote><p>说明：在c++的string类种是重载了<code>+</code>,改运算符返回的也是string类型，分析</p><ol type="1"><li>s4, <code>s1</code>是string类型，会调用重载的 <code>+</code></li><li>s5, <code>hello</code> 和 <code>,</code> 都是<code>const char*</code> 类型，该类型并没有定义 <code>+</code> 运算</li><li>s6, <code>(s1 + ", ")</code> 和s4 一样，得到的是一个临时的 string，再 <code>+ "world"</code></li><li>s7, <code>"hello" + ", "</code> 的错误和s5一样</li></ol></blockquote><h2 id="多维数组">6. 多维数组</h2><p><strong>初始化</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> arr[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;&#123;<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">4</span>&#125;,&#123;<span class="hljs-number">8</span>&#125;&#125;;<span class="hljs-comment">//初始化每行的首元素</span><br><span class="hljs-type">int</span> arr2[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;; <span class="hljs-comment">// 初始化第一行</span><br></code></pre></td></tr></table></figure><p><strong>使用范围 for 语句处理多维数组</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> ia[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;row : ia)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> col : row)<br>        cout&lt;&lt;col&lt;&lt;endl;<br></code></pre></td></tr></table></figure><blockquote><p>将外层循环的控制变量声明成了引用类型，是为了<strong>避免数组被自动转成指针</strong>，因为<code>auto row : ia</code>会将row的类型识别为int*，则内层循环不合法。</p><p>要使用范围 for语句处理多维数组，除了最内层的循坏外，其他所有循环的控制变量都应该是引用类型。</p></blockquote><p><strong>指针和多维数组 </strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ;">int arr[3][4];<br>int (*p)[4] = arr; // p指向含有4个int型的数组<br>p = &amp;arr[2];       // p指向arr的尾元素<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++ Primer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/02/08/Ch4-%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2023/02/08/Ch4-%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="第4章-表达式">第4章 表达式</h1><h2 id="基础">1. 基础</h2><p>一些运算符的基本概念</p><h3 id="基本概念">1.1 基本概念</h3><p>#### 重载运算符</p><p>赋予基本运算符不同的含义和运算方式，使用重载运算符时，其包括运算对象的类型和返回值的类型，都是由该运算符定义的；但是运算对象的个数、运算符的优先级和结合律都是无法改变的。</p><h4 id="左值和右值">左值和右值</h4><p>左值，使用的是对象的<strong>身份</strong>（在内存中的位置）；右值，使用的是对象的<strong>值</strong>（内容）。</p><h3 id="优先级与结合律">1.2 优先级与结合律</h3><p>基本的运算优先级和数学中的优先级一样。</p><p>括号无视优先级，在不确定默认的优先级时可以使用括号。</p><h2 id="算术运算符">2. 算术运算符</h2><p>常用算术运算符</p><figure><img src="https://kinvy-images.oss-cn-beijing.aliyuncs.com/Images/image-20211224155915096.png" alt="image-20211224155915096"><figcaption aria-hidden="true">image-20211224155915096</figcaption></figure><h2 id="逻辑和关系运算符">3. 逻辑和关系运算符</h2><p>逻辑和关系运算符</p><figure><img src="https://kinvy-images.oss-cn-beijing.aliyuncs.com/Images/image-20211224160003044.png" alt="image-20211224160003044"><figcaption aria-hidden="true">image-20211224160003044</figcaption></figure><p><strong>短路原则</strong>：</p><ul><li>对于逻辑与运算符来说，当且仅当左侧运算对象为真时才对右侧运算对象求值</li><li>对于逻辑或运算符来说，当且仅当左侧运算对象为假时才对右侧运算对象求值</li></ul><h2 id="赋值运算符">4. 赋值运算符</h2><p>赋值和初始化是两个不同的概念，虽然都使用 <code>=</code> 运算符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> i = <span class="hljs-number">10</span>, k = <span class="hljs-number">0</span>;<span class="hljs-comment">//这里是初始化，不是赋值操作</span><br><span class="hljs-type">int</span> j;<span class="hljs-comment">//声明定义一个变量</span><br>j = <span class="hljs-number">1</span>;<span class="hljs-comment">//赋值操作</span><br></code></pre></td></tr></table></figure><p><strong>赋值运算符满足右结合律</strong>。对于多重赋值语句中的每一个对象，它的类型或者与右边对象的类型相同、或者可由右边对象的类型转换得到</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i,j;<br>i = j = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 正确，都被赋值为0</span><br><span class="hljs-type">int</span> v, *p;<br>v = p = <span class="hljs-number">0</span>; <span class="hljs-comment">// 错误，不能把指针的值赋给int</span><br></code></pre></td></tr></table></figure><h2 id="递增和递减运算符">5. 递增和递减运算符</h2><p>递增（递减）运算符有前置（<code>++i</code>）和后置（<code>i++</code>）</p><p>前置将运算对象加 1 (或减 1),并返回<strong>改变后</strong>的对象；后置版本将运算对象加 1 (或减 1),但返回<strong>改变前</strong>那个值的副本 。</p><blockquote><p>如果没有特别的需求，建议使用前置的版本</p><p>e.g.: <code>*iter++</code>实现一个对象的遍历</p></blockquote><h2 id="成员访问运算符">6. 成员访问运算符</h2><p>成员运算符有<strong>点运算符</strong> 和<strong>箭头运算符</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//这两个表达式是等价的</span><br>ptr-&gt;mem;<br>(*ptr).mem;<span class="hljs-comment">//* 优先级低于 . 所以要加括号</span><br></code></pre></td></tr></table></figure><h2 id="条件运算符">7. 条件运算符</h2><p>条件运算符 <code>?:</code> 是一个三元运算符，格式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cond ? expr1 : expr2;<br><span class="hljs-comment">//等价形式</span><br><span class="hljs-keyword">if</span> (cond)<br>    expr1;<br><span class="hljs-keyword">else</span><br>    expr2;<br></code></pre></td></tr></table></figure><h2 id="位运算符">8. 位运算符</h2><p>位运算符是在二进制的层面对数据操作，以下是常用的位运算符</p><figure><img src="https://kinvy-images.oss-cn-beijing.aliyuncs.com/Images/image-20211224162959652.png" alt="image-20211224162959652"><figcaption aria-hidden="true">image-20211224162959652</figcaption></figure><h2 id="sizeof-运算符">9. sizeof 运算符</h2><p><code>sizeof</code>运算符返回一条表达式或一个类型名字所占的字节数。该运算符有两种形式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Sales_data data, *p; <br><span class="hljs-built_in">sizeof</span>(type);<br><span class="hljs-keyword">sizeof</span> expr; <span class="hljs-comment">// 返回expr的类型的大小，不会实际计算</span><br><span class="hljs-keyword">sizeof</span> p;    <span class="hljs-comment">// 指针所占的空间大小</span><br><span class="hljs-keyword">sizeof</span> *p;   <span class="hljs-comment">// p所指类型的空间大小 </span><br></code></pre></td></tr></table></figure><h2 id="逗号运算符">10. 逗号运算符</h2><p><strong>逗号运算符</strong>含有两个运算对象，按照从左向右的顺序依次求值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt;::size_type cnt = ivec.<span class="hljs-built_in">size</span>();<br><span class="hljs-comment">//将把从size到1的值赋给ivec的元素</span><br><span class="hljs-keyword">for</span>(vector&lt;<span class="hljs-type">int</span>&gt;::size_type ix = <span class="hljs-number">0</span>; <br>   ix != ivec.size; ++ix, --cnt)<br>    ivec[ix] = cnt;<br></code></pre></td></tr></table></figure><h2 id="类型转换">11. 类型转换</h2><h4 id="隐式转换">隐式转换</h4><p>由编译器完成，可能会出现精度损失</p><h4 id="显示转换">显示转换</h4><p>命名类型的强制类型转换，其形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">cast-<span class="hljs-built_in">name</span>&lt;type&gt;(expression);<br></code></pre></td></tr></table></figure><p>其中<code>type</code>是转换的目标类型而 <code>expression</code>是要转换的值。如果 <code>type</code> 是引用类型，则结果是左值。</p><p><code>cast-name</code> 是<code>static_cast</code>、<code>dynamic_cast</code>、<code>const_cast</code>、<code>reinterpret_cast</code>中的一种。</p><p><strong>static_cast</strong> ,任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//进行强制类型转换以便执行浮点数除法， j, i是int</span><br><span class="hljs-type">double</span> slope = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">double</span>&gt;(j) / i;<br></code></pre></td></tr></table></figure><p><strong>const_cast</strong>, 只能改变运算对象的底层const</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *pc;<br><span class="hljs-type">char</span> *p = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(pc); <span class="hljs-comment">// 正确，但是通过p写值是未定义的行为</span><br><span class="hljs-built_in">const_cast</span>&lt;string&gt;(pc); <span class="hljs-comment">// 错误，const_cast只改变常量属性</span><br><br><span class="hljs-type">char</span> *q = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(pc); <span class="hljs-comment">//错误，static_cast不能转换掉const性质</span><br><span class="hljs-built_in">static_cast</span>&lt;string&gt;(pc); <span class="hljs-comment">// 正确，字符串字面值转换成string类型</span><br></code></pre></td></tr></table></figure><p><strong>reinterpret_cast</strong>,通常为运算对象的位模式提供较低层次上的重新解释<em>这里不是很明白</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> *ip;<br><span class="hljs-type">char</span> *pc = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(ip);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++ Primer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第5章 语句</title>
    <link href="/2023/02/08/Ch5-%E8%AF%AD%E5%8F%A5/"/>
    <url>/2023/02/08/Ch5-%E8%AF%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="第5章-语句">第5章 语句</h1><h2 id="简单语句">1. 简单语句</h2><h4 id="表达式语句">表达式语句</h4><p>表达式加上分号就是一条语句</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ival + <span class="hljs-number">5</span>;<span class="hljs-comment">//一条没有实际作用的表达式语句</span><br>cout &lt;&lt; ival;<span class="hljs-comment">//一条有用的表达式语句</span><br></code></pre></td></tr></table></figure><h4 id="空语句">空语句</h4><p>一个分号 <code>;</code> 就是空语句</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">;<span class="hljs-comment">//空语句</span><br>ival = v1 + v2;;<span class="hljs-comment">//第二分号是空语句，没有影响</span><br><span class="hljs-keyword">while</span> (iter != svec.<span class="hljs-built_in">end</span>()) ;<span class="hljs-comment">//分号是空语句，导致下面的语句不会出现在循环中执行</span><br>++iter;<span class="hljs-comment">//不属于循环体的一部分</span><br></code></pre></td></tr></table></figure><blockquote><p>空语句单独不会有什么作用，但是和其他语句组合会有不同的作用。</p><p>注意：别漏写分号，也别多写分号</p></blockquote><h4 id="复合语句">复合语句</h4><p>复合语句也就<strong>块</strong>， 就是用一对 <code>&#123;&#125;</code>括起来的多个语句</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span> (val &lt; <span class="hljs-number">10</span>) &#123;<br>    sum += val;<br>    ++val;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>块不以分号作为结束，但是在声明定义类时<code>&#123;&#125;</code> 后要加<code>;</code></p></blockquote><h2 id="条件语句">2. 条件语句</h2><h3 id="if-语句">2.1 if 语句</h3><p><code>if</code> 语句的语法形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (condition)<br>    statement<br><span class="hljs-comment">//if else 语句</span><br><span class="hljs-keyword">if</span> (condition)<br>    statement<br><span class="hljs-keyword">else</span><br>    statement2<br></code></pre></td></tr></table></figure><p>使用注意：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//1. 注意使用花括号</span><br><span class="hljs-keyword">if</span> (grade &lt; <span class="hljs-number">60</span>)<br>    lettergrade = scores[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">else</span><span class="hljs-comment">//错误： 下面的语句应该全部属于else的部分，需要加花括号</span><br>    lettergrade = scorses[(grade - <span class="hljs-number">50</span>)/<span class="hljs-number">10</span>];<br><span class="hljs-keyword">if</span>(grade != <span class="hljs-number">100</span>)<br>        <span class="hljs-keyword">if</span>(grade % <span class="hljs-number">10</span> &gt; <span class="hljs-number">7</span>)<br>            lettergrade += <span class="hljs-string">&#x27;+&#x27;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(grade % <span class="hljs-number">10</span>  &lt; <span class="hljs-number">3</span>)<br>            lettergrade += <span class="hljs-string">&#x27;-&#x27;</span>;<br><br><span class="hljs-comment">//2.悬垂else，else与最近的尚未匹配的if匹配</span><br><span class="hljs-keyword">if</span> (grade % <span class="hljs-number">10</span> &gt; = <span class="hljs-number">3</span>)<br>    <span class="hljs-keyword">if</span>(grade % <span class="hljs-number">10</span> &gt; <span class="hljs-number">7</span>)<br>        lettergrade += <span class="hljs-string">&#x27;+&#x27;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-comment">// 实际匹配内层的if</span><br>    lettergrade += <span class="hljs-string">&#x27;-&#x27;</span>;<br></code></pre></td></tr></table></figure><blockquote><ul><li>尽量每个if-else中的语句块加上花括号<code>&#123;&#125;</code></li><li>if-else的匹配原则是就近原则，空格和缩进在c++是不会作用的，不像某些语言（点名python)</li></ul></blockquote><h3 id="switch-语句">2.2 switch 语句</h3><p>格式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">switch</span>(lables) &#123;<br>    <span class="hljs-keyword">case</span> lable1:<br>        statement;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> lable2:<br>        statement;<br>        <span class="hljs-keyword">break</span>;<br>        ...<br>    <span class="hljs-keyword">default</span>:<br>        statement;<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：</p><ul><li>lable1, lable2,... 必须是<strong>整型常量表达式</strong></li><li>如果某个case标签匹配成功，将从该标签开始往后顺序执行所有case分支，除非程序显示地中断了这一过程。</li><li>如果不是特殊的需求，每个case都需要加 <code>break</code>,否则会一直执行下面的标签</li><li><code>default</code> 标签建议写上</li><li>在不同两个标签定义的变量，不要跨标签使用（如果需要为某个分支定义并初始化一个变量，应该把变量定义在块内，即使用{}）</li></ul></blockquote><h2 id="迭代语句">3. 迭代语句</h2><p><code>while</code>和<code>for</code>语句在执行循环体之前检查条件，<code>do while</code>语句先执行循环体，然后再检查条件。</p><h3 id="while语句">3.1 while语句</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span> (condition)<br>    statement<br></code></pre></td></tr></table></figure><h3 id="do-while-语句">3.2 do-while 语句</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">do</span></span><br><span class="hljs-function">    statement</span><br><span class="hljs-function"><span class="hljs-title">while</span> <span class="hljs-params">(condition)</span></span>; <span class="hljs-comment">// 不要忘记 ;</span><br></code></pre></td></tr></table></figure><h3 id="传统的for语句">3.3 传统的for语句</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (init-statement; condition; expression)<br>    statement<br></code></pre></td></tr></table></figure><blockquote><p>init_statement可以定义多个对象，但只能有一条声明语句，因此所有变量的类型必须相同。</p></blockquote><h3 id="范围for语句">3.4 范围for语句</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (declaration : expression)<br>    statement<br></code></pre></td></tr></table></figure><blockquote><p>expression表示的必须是一个序列，比如用花括号括起来的初始值列表、数组或者vector 或 string 等类型的对象，这些类型的共同特点是拥有能返回迭代器的begin 和 end 成员。</p></blockquote><h2 id="跳转语句">4. 跳转语句</h2><h3 id="break-语句">4.1 break 语句</h3><p><code>break</code> 负责终止离它最近的 while、dowhile、for、或switch语句</p><h3 id="continue-语句">4.2 continue 语句</h3><p>结束当前迭代，并进入下次迭代</p><h3 id="goto语句">4.3 goto语句</h3><p>从 goto 语句无条件跳转到同一函数内的另一条语句。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">goto</span> label；<br></code></pre></td></tr></table></figure><p>label是用于标识一条语句的标示符。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">end: <span class="hljs-keyword">return</span>; <span class="hljs-comment">// dai&#x27;biao&#x27;q</span><br>&gt; <span class="hljs-keyword">goto</span>语句很好用，但是不建议用，会导致你代码结构比较乱<br><br>## <span class="hljs-number">5.</span> <span class="hljs-keyword">try</span>语句块和异常处理<br><br>### <span class="hljs-number">5.1</span> <span class="hljs-keyword">throw</span>表达式<br><br><span class="hljs-keyword">throw</span>用于抛出异常<br><br>```cpp<br><span class="hljs-keyword">if</span>(item1.<span class="hljs-built_in">isbn</span>() != item2.<span class="hljs-built_in">isbn</span>())<br>    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Data must refer to same ISBN&quot;</span>)；<br></code></pre></td></tr></table></figure></p><h3 id="try-语句块">5.2 try 语句块</h3><p>语法形式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">try</span>&#123;<br>    program-satements;<br>&#125; <span class="hljs-built_in">catch</span> (exception-declaration) &#123;<br>    handler-statements;<br>&#125; <span class="hljs-built_in">catch</span> (exception-declaration) &#123;<br>    handler-statements;<br>&#125;<span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><blockquote><p>program-satements 是我们用运行的语句</p><p>catch (exception-declaration)表示的是可能会出现的异常以及相对应的异常处理语句</p></blockquote><h2 id="标准异常">5.3 标准异常</h2><p>c++标准库定义了一组类，用于报告标准库函数遇到的问题，它们分别定义在4个头文件中</p><ul><li><code>exception</code> 头文件定义了最通用的异常类,它只报告异常的发生，不提供任何额外信息</li><li><code>stdexcept</code> 头文件定义几种常用的异常类，详细见下表</li><li><code>new</code> 头文件定义了 bad_alloc异常类型</li><li><code>type_info</code> 头文件定义了bad_cast异常类型</li></ul><figure><img src="https://kinvy-images.oss-cn-beijing.aliyuncs.com/Images/image-20211225124654765.png" alt="image-20211225124654765"><figcaption aria-hidden="true">image-20211225124654765</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++ Primer</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
